# Redis分布式锁的三种实现：

## 1. 基于数据库实现

可以创建一个表，把方法名作为主键，执行某个方法时，向表中插入数据，执行完则删除对应的行，释放锁

## 2. 基于缓存实现

主要用setnx、expire，delete三个指令来实现

- setnx：如果key不存在，则set一个k，v，如果存在，返回0
- expire：设置超时时间
- delete：删除key

1. 获取锁：如果key不存在，则插入一堆k-v，设置过期时间，v一般为UUID，在释放锁时进行判断。
2. 如果超时，自动放弃锁（否则可能会出现死机导致一直不释放的情况
3. 释放锁：判断UUID是不是该锁，如果是，则执行delete进行释放（若不判断，可能会出现没死机，但是超时了，锁被别的线程获取，然后释放别的锁的情况）

**注意：**判断锁表示和删除是两步，需要保证原子性

可以使用Lua脚本，用来保证执行命令时的原子性。

## 3.基于Zookeeper实现分布式锁

ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：

（1）创建一个目录mylock；
（2）线程A想获取锁就在mylock目录下创建临时顺序节点；
（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。

优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式

