## 一：动态字符串

Redis构架了一种名为简单动态字符串（simple dynamic string,SDS）的抽象类型，作为自己的默认字符串.除了保存数据之外，还可用作缓冲区：AOF模块中的AOF缓冲区，输入缓冲区。
### SDS的定义
```c
sruct sdshdr {
	//记录buff数组中已使用的字节制度程度，不包括'\0'，即字符串程度
	int len;
	//记录未使用字节数量
	int free;
	//字节数组
	char buf[];
}
```
- 遵循C字符串空字符结尾惯例，'\0'的一字节空间不在计算范围内。
- 直接重用了一部分C字符串的函数，例如打印函数（printf）
###  SDS的特点
- C字符串：
	- 使用长度为N+1的字符数组，以'\\0'结尾，不能满足Redis对字符串安全性，效率以及功能方面的要求，字符串长度与底层字符数组空间相关联
	- 本身不记录自身的长度，获取自身长度需要遍历整个字符数组，时间复杂度O(n)。
	- 不记录自身长度还会导致容易导致缓冲区溢出![Cstring缓冲区溢出.png](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture/202305251026452.png)
		- 若在djccc后面插入字符串，会默认空间足够，导致覆盖别的字符串对象
	- 内存重分配次数比较多，每次增长或缩短买都会进行一次内存重分配操作。
	- 二进制不安全
- SDS：
	- 常数复杂度获取字符串长度
		- 因为结构体内有一个len属性记录了SDS的长度，每次字符串修改后都会自动修改len，这样可以O(1)复杂度获取字符串长度。
	- 杜绝缓冲区溢出
		- 结构体中有一个len和free属性，当需要修改字符串对象时，会让len与free相加，与要修改的字符串长度比较，若足够则在原本基础上修改，否者重新开辟一段内存空间，拓展对象空间。（包括空间预分配）
	- 减少修改字符串时带来的内存重分配次数
		- 增长或缩短都可能会导致内存重分配操作：
			- 情景：
				- 若增长后的长度大于底层字节数组空间，需要内存重分配
				- 若缩短后不再使用那部分空间，由于没有修改数组，空间会一直占用，会产生内存泄漏
				- 若一般情况下不太经常修改程度可以介绍，但Redis频繁修改，所以要减少内存空间重分配的次数。
				- 有空间与分配和惰性空间释放两种策略。
			- 空间预分配
				- 拓展SDS空间之前会判断未使用空间（free）是否足够，若足够，则不需要拓展。
				- 对SDS进行空间拓展的时候，不进会分配所修改必须要的空间，还会分配未使用的空间。
				- 若SDS修改后的长度（即len）将小于1MB，那么将分配与len等长的空间，即len=free，若大于等于1MB，会分配1MB未使用空间，即free=1MB。
			- 惰性空间释放
				- 缩短空间时，不会立即通过内存重分配回收未使用空间，而是会使用free来记录下来，以便在以后增长的时候利用，减少增长时导致的内存重分配，以及本次缩短导致的内存重分配。
				- 通时，SDS提供了相应的API，可以在有需要的时候释放SDS未使用的·空间，不需要担心惰性空间释放策略造成的内存浪费。
				- 另外可能会导致**内存碎片**问题，当SDS的未使用空间散布在SDS字符串的各个位置时，可能会出现无法分配连续内存块的情况，从而导致内存碎片。为了解决这个问题，Redis提供了内存碎片整理（memory defragmentation）功能，可以将SDS字符串的内容移动到连续的内存块中，从而消除内存碎片。但是，内存碎片整理需要消耗额外的时间和资源，因此需要在必要时才进行。
	- 二进制安全
		- buf是字节数组而不是字符数组，是二进制安全的。C的字符串字符数组必须符合某种二进制编码，只能保存文本文件。
		- 不是用这个数组来保存字符的，而是来保存一系列二进制数据，所以保存'\\0'等一些特殊字符都没关系，因为他是通过len而不是'\\0'来判读是否结束的，字节数组也可以保存一些特殊的数据如音频，视频等，不会对其中的数据做任何限制、过滤、或者假设，数据写入是什么样的，读取就是什么样的。
	- 兼容部分C字符串函数
		- 他在结尾用'\\0'是为了保存文本数据的那些SDS可以重用一部分<string.h>库定义的函数，例如对比函数（<string.h>/strcasecmp）、追加函数（将SD作为地个人股参数追加到C字符串后面。

## 二：链表

### 链表的定义：

当一个列表键包含了数量比较多的元素或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。 除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，redis服务器本身还用链表来构建客户端输出缓冲区。

### 链表的实现：

- 每个链表节点使用一个adlist.h/listNode结构来表示：
```c
typedef struct listNode {
	//前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```
- 多个listNode组成双端链表，通过adlist.h/list来持有链表
```c
typedef struct list {
	//表头节点
    listNode *head;
    //表尾节点
    listNode *tail;
    //节点复制函数
    void *(*dup)(void *ptr);
    //节点释放函数
    void (*free)(void *ptr);
    //节点对比函数
    int (*match)(void *ptr, void *key);
    //链表所包含的节点数量
    unsigned long len;
} list;
```
- Redis的链表实现的特性：
	- 双端： 有prev和next指针，获取某个节点的前置节点和后置节点的负责的均为O(1)
	- 无环：表头节点的prev和表尾结点的next均指向null，对链表的访问以NULL为终
	- 带表头和尾指针：通过list的head和tail指针，获取表头表尾复杂度尾O(1)
	- 带链表长度计数器：list里的len，对list持有节点数量进行统计。
	- 多态：链表节点使用void* 指针保存节点值，可以通过list结构中的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值

## 三：字典

### 字典的定义：

字典在Redis中应用非常广泛，Redis的数据库就是使用字典来作为底层实现的。此外还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。
### 字典的实现：

Redis的字典是使用哈希表作为底层实现，哈希表里面可以有多个哈希节点，每个哈希节点保存了一个键值对。

#### 哈希表：

- Redis字典使用的哈希表有dict.h/dictht定义
- table是一个数组，每个元素是指向dict.h/dictEntry结构体的指针，每个dictEntry结构保存了一个键值对
- size记录了哈希表的大小（table数组大小）
- used记录了哈希表目前已有节点的数量
- sizemask等于size-1，和哈希值一起决定了键应该放到table的哪个索引上

```c
typedef struct dictht{
	//哈希表数组
	dictEntry **table;
	//哈希表大小
	unsigned long size;
	//哈希表大小掩码，用于计算索引值
	//总是等于size-1
	unsigned long sizemask;
	//该哈希表已有的节点的数量
	unsigned long used;
} dictht
```
#### 哈希节点：

- k保存键，v保存值，值可以是一个指针、uint64_t整数或int64_t整数。
- next指向下一个哈希节点，当哈希值相同的时候，在dictht哈希数值（table）的指针进行头插法。以此来解决键冲突的问题。

```c
typedef struct dictEntry{
	//键
	void *key；
	//值
	union {
		void *val;
		uint63_t u64;
		int64_t s64;
	}v;
	//下一个哈希节点
	struct dictEntry *next;
}dictEntry;
```
#### 字典：

- Redis中字典由dict.h/dict结构表示
- type和privdata是为了针对不同类型的的键值对创建的多态字典而设置的。
- type是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为不同字典设置不同类型操作函数。
- privdata保存了需要传给那些特定函数的可选参数
- **ht**是一个包含了两个dictht哈希表的数组，一般情况下字典只使用ht[0]，ht[1]只有在对ht[0]进行rehash的时候会使用
- trehashidx用来标志rehash的进度，若没有进行rehash，则trehashidx为-1
```c
typedef struct dict{
	//
	dictType *type;
	//所有数据
	void *privdata;
	//哈希表
	dictht ht[2];
	//rehash索引
	//当rehash不在进行时，值为-1
	long trehashidx; /* rehashing not in progress if rehashidx == -1 */
}

typedef struct dictType {  
  uint64_t (*hashFunction)(const void *key);  
  void *(*keyDup)(dict *d, const void *key);  
  void *(*valDup)(dict *d, const void *obj);  
  int (*keyCompare)(dict *d, const void *key1, const void *key2);  
  void (*keyDestructor)(dict *d, void *key);  
  void (*valDestructor)(dict *d, void *obj);  
  int (*expandAllowed)(size_t moreMem, double usedRatio);  
  unsigned int no_value:1;  
  unsigned int keys_are_odd:1;  
  size_t (*dictEntryMetadataBytes)(dict *d);  
  size_t (*dictMetadataBytes)(void);  
  void (*afterReplaceEntry)(dict *d, dictEntry *entry);  
} dictType;
```
![字典数据结构.drawio.png](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture/202305261429753.png)

### 哈希算法及特点

- 将新的键值对要插入到字典里时，根据键值对的键计算出哈希值和索引值，然后根据索引值放到哈希数表数组的指定索引上。
	- hash=hash->type->hsahFunction(key);//计算哈希值
	- index=hash & dict->ht[x].sizemask;//计算索引值
	- 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Reis使用MurmurHash2算法来计算键的哈希值。
- 哈希冲突：
	- 当两个或多个减被分到同一个索引上时，称发生了哈希冲突
	- 通过头插法，把新的节点插入到链表的表头位置。
- rehash：
	- 随着操作的不断执行，哈希表保存的键值对会逐渐的增多或减少，为了让哈希表的负载因子维持在一个合理的范围内，当哈希表保存的键值对太多或太少时，对哈希表的大小进行相应的拓展或收缩（哈希表数组，dicht的dictENtry ** table大小）。
	- 哈希表索引过少的问题：
		- 内存利用率低：哈希表的索引空间不足时，会导致每个哈希桶（bucket）中的链表较长，增加了冲突和遍历的开销。这会占用更多的内存空间，并且影响了哈希表的性能。
		- 查询效率低：哈希表的索引空间不足时，查找特定键的效率较低。需要遍历较长的链表来找到目标键，增加了查找的时间复杂度。
	- 哈希表索引过多的问题：
		- 内存开销大：哈希表的索引空间过多会占用更多的内存空间，导致内存的浪费。
		- 内存碎片化：过多的索引空间可能会导致内存碎片化问题，使得内存的连续可用空间变少。
		- 
	- rehash步骤：
		1. 为字典的ht[1]哈希表分配空间，空间大小取决于要执行的操作以及[0]当前包含的键值对数量(即ht[0].used属性的值)
			-  若为拓展操作，这ht[1]大小为第一个大于等于ht[0].used* 2   的2^n的数
			-  若为收缩，这ht[0]大小为第一个大于等于ht[0].used   的2^n的数
		2. 将保存在ht[0]中所有键值对rehash到ht[1]上，在过程中，并没有重新分配内存或复制节点数据。节点仍然保持原有的地址和数据内容，只是将节点的指针从 `ht[0]` 桶中的位置修改为 `ht[1]` 桶中的位置。
		3. 当rt[0]包含的所有键值对转移到ht[1]之后，释放ht[1],将ht[1]设置为ht[0],并在ht[1]新创建一个空白的哈希表，为下次rehash做准备
- 执行拓展或收缩的条件：
	- 负载因子=哈希表已保存节点数/哈希表大小
	- 拓展（满足任意一个）：
		- 服务器目前没有执行BGSAVE或者BGREWRITEAOP命令。并且哈希表的负载因子大于等于1
		- 服务器正在执行BGSAVE或者BGREWRITEAOP命令并且哈希表负载因子大于等于5
		- 原因：在执行BGSAVE或者BGREWRITEAOP命令时，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用**写时复制**技术来优化子进程的使用效率，所以提供所需的负载因子来避免进行哈希拓展操作，这样可以避免不必要的内存写入，最大限度地节约内存。
	- 当负载因子小于0.1时进行收缩操作。
	- 关于写时复制：Redis在执行BGSAVE或BGREWRITEAOF命令时，会fork出一个子进程来生成rdb文件或重写AOF文件，采用写时复制技术，父子进程共享同一片内存区域，当任一进程企图对这片内存区域进行写入操作时，会把将要写入的那一部分内存页复制一份进行写入，其他内存页依旧共享。在字典扩容期间，父进程要迁移数据，不可避免的会有大量内存写入操作，为了减少内存页过多的复制，而提高了扩容的门限，这是出于节省内存考虑的。至于为什么Redis字典收缩时不用考虑写时复制？我认为原因有两个：一是收缩条件是键值对个数小于哈希表长度的10%，有意设置的这么低，就是为了不会造成过多的页分离；二是收缩操作完成会释放一部分内存，本身目的就是节省内存的。所以两个原因综合起来，不用考虑写时复制对收缩的影响。参考[[基础/小知识点/写时复制|写时复制]]
- 渐进式rehash
	- rehash的动作不是一次完成的，而是分多次、渐进式的完成的。
		- 如果键值对过多，如果要一次性完成可能会造成庞大的计算量导致服务器在一段时间内停止服务。
	- 步骤：
		1. 为ht[1]分配空间，让字典同时拥有ht[1]和ht[2]两个哈希表
		2. 在字典中维护索引计数器变量rehashidx，用来记录rehash进度（每迁移完ht[0]的一个索引就会+1），将他设为0，表示rehash正式开始。
		3. 在rehash期间，每次对字典执行增删改查操作时，除了完成这些操作，还会顺带将ht[0]在hashidx索引上的键值对rehash到ht[0]中，当在rehashidx索引上的所有键值对都rehash过去后，rehashidx+1
		4. 最终所有键值对都会rehash到ht[1]上，这时**将新哈希表设为主哈希表，并释放旧哈希表**。后将rehashidx=-1。标志已经rehash完成。
	- 渐进式rehash的1好处：采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典每个增删改查操作上，从而避免了集中式rehash带来的庞大计算量
- 渐进式rehash执行期间的哈希表操作
	- 会同时使用ht[0]和ht[1],两个哈希表，所以在rehash过程中，增删改查会在两个表上操作。
		- 新增操作：直接将键值对插入到ht[1]上，保证ht[0]的结点不会增加；
		- 删除操作：同时在ht[0]和ht[1]两个哈希表上执行，避免漏删；
		- 修改操作：同时在ht[0]和ht[1]两个哈希表上执行，避免漏改；
		- 查找操作：先从ht[0]查，查不到的话再去ht[1]查；

## 四：跳跃表

### 跳跃表的定义：

跳跃表是一种有序地数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的

### 跳跃表的特点：

跳跃表支持平均O（logN），最坏O(n）负责的杜节点处=查找，还可以通过顺序性操作来批量处理节点。

在大多数情况下，跳跃表的效率可以与平衡树媲美，并且因为跳跃表的实现比平衡树更简单，所以有不少程序都使用跳跃表来代替平衡树

### 使用场景：

只在两个地方使用，一个是实现有序键集合·，另一个是在集群节点中作为内部数据结构，除此之外，跳跃表在Redis中没有其他用途。

如果一个有序集合包含的元素数量比较多或者有序键集合中元素成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。

### 跳跃表的实现：

跳跃表由server.h/zskiplist 和zskiplistNode定义，Node表示跳跃表节点，而zskiplist由于保存跳跃表节点的相关信息，比如节点数量，头指针，尾指针，最大高度。

头结点是一个32层的空节点，用来指向后面节点，默认跳跃表节点层高在1-32之间，分布是按幂分布，越高层概率越低。

![image-20230815105650149](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151056182.png)

- level表示层级数组，每一层都有下一个节点的地址以及跨度。
- 每个节点都有一个分值，各个节点的额对象必须是唯一的，而保存的分钟可以相同，所有节点是按各自的分值来排序的，若分值相同，后按对象在字典序中的大小；来进行排序。（字典序：基于ASCLL或者Unicode编排比较字符串的方法）

![image-20230815110513901](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151105945.png)

![image-20230815110554412](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151105461.png)

#### 跳跃表插入的实现：

- 插入的时候可以把跳表的每一层当做一个链表，从高到低进行插入。
- 高层跨度比较大，所以要插入的位置一定在高层插入位置或者它的右边
- 在高层找到插入位置后，在这个上一个节点的下一层继续往后遍历，找到找到本层插入位置，插入后继续在插入位置前一个节点的下一层执行插入，找到完成第一层的插入。

此外，查询和插入类似，只不过省去了插入的步骤，

删除也和插入步骤类似，保证每层·的链表都不会断掉。

## 五：整数集合

整数集合是集合键的底层实现之一，当一个集合只包含整数数值元素，并且这个集合数量不多时，Redis就会使用整数集合作为集合键的底层实现。

### 整数集合的实现：

![image-20230815111829681](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151118722.png)

整数集合(intset)是Redis用与保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复的元素。

- contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中安值的大小有序地排列，并且数组中不包含任何重复项。
- length属性记录了整数集合包含的元素数量，也即是contents数组长度。
- 虽然intset结构将content属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组`真正的类型取决于encoding三星的值`

### 整数集合的升级：

当我们要将一个新元素添加到整数集合中，并且新元素的类型比整数集合现有的有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步：

1. 根据新元素的类型，拓展整数集合底层数组的空间大小，并且为新元素分配空间。
2. 将底层数组现有的所有元素都转换为与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性不变
3. 将新元素添加到底层数组里面。

参考书上内容：

![image-20230815114243255](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151142471.png)

> 触发升级的新元素比现有所有元素都长，所以他要么比现有所有元素大，要么小，即要么放最后，要么开头

- 升级的好处：
  - 提升灵活性
    - 通过自动升级来适应新元素，所以可以随意地将不同类型的整数添加到集合中，不必担心类型错误
  - 节约内存
    - 可以确保升级操作只会在需要时进行，可以尽量节约内存

> 整数集合不支持降级操作，一旦进行了升级，就会一直保存升级后的状态。

## 六：压缩列表

压缩列表是列表键和哈希键的底层实现之一。当一个列表键值包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

另外，当一个哈希键值包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

> 本质上是一个字节数组

### 压缩列表的实现：

#### 压缩列表的构成：

压缩列表是Redis为了节约内存而开发的，是由一系列特色编码的连续内存快组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。

![ziplist.drawio](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151317777.png)

| 属性    | 类型      | 长度  | 用途                                                         |
| ------- | --------- | ----- | ------------------------------------------------------------ |
| zlbytes | unint32_t | 4字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配或者基数按zlend的位置是使用 |
| zltail  | unint32_t | 4字节 | 记录压缩列表列表表尾节点距离压缩列表起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | unint16_t | 2字节 | 记录了压缩列表压缩列表包含的节点数量：这个属性小于unint16_MAX时表示数量，当大于时，需要遍历整个压缩列表来计算（溢出了就无法表示它的数量了 |
| entry   | 列表节点  | 不定  | 压缩列表包含的各个节点，节点长度有节点保存的内容决定         |
| zlend   | unint8_t  | 1字节 | 特色值OxFF（10进制255）,用于标记压缩列表的末端               |

### 压缩列表节点的构成：

![image-20230815144520046](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151445082.png)

每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是一下三种长度之一：

- 长度小于等于63(2^6-1)字节的数组
- 长度小于大于16383（2^14-1）字节数组
- 长度小于等于4 294 967 295 （2^32-1）字节的数组

而整数有以下六种长度：

- 4位长度，介于0-12之间的无符号整数
- 1字节长的有符号整数
- 3字节长的有符号整数
- int16_t类型整数
- int32_t类型整数
- int64_t类型整数

#### previous_entry_length:

以字节为单位，记录了压缩列表中前一个节点的长度

他的长度可以是一个字节或者五个字节：

- 如果前一个节点的长度小于254字节，那么previous_entry_length的长度为`1字节`：前一个节点的长度就保存在这一个字节里面
- 如果前一个节点的长度大于154字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为OxFE（10进制254），而之后的四个字节则用于保存前一节点的长度。

> 基于这一特性，程序可以通过指针运算，根据当前节点的起始位置计算前一个节点的起始位置，可以实现压缩列表从表位向表头的遍历。

#### encoding：

encoding记录了节点的content属性所保存的数据类型以及长度

一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；

一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；

![image-20230815144546814](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151445874.png)

#### content：

**content属性负责保存节点的值，值的具体类型由上一个字段encoding来决定。**

例如存储字节数组，00表示类型为字节数组，01011表示长度为11

![image-20230815144343687](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151443739.png)

存储整数值，表示存储的为整数，类型为int16_t

![image-20230815144354569](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151443612.png)

### 连锁更新：

添加一个节点后，可能会导致后面的节点的previous_entry_length需要增大，而后一个节点增大后，可能也超过了254，导致后面的节点继续增大，这样的情况叫做连锁反应。

> 除了添加新节点外，删除节点也可能会引发连锁更新

因为连锁股更新在最坏的情况需要对压缩列表执行N次空间重新分配操作，而每次空间重分配的最坏复杂度为O(n)，所以连锁更新的最坏复杂度为O(N^2).

- 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实例中，这种情况并不多见
- 其次，即使出现连锁更新，但主要被更新的节点数量不多，就不会对性能造成任何影响：比如三五个节点进行连锁更新是绝对不对印象性能的。

