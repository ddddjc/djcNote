## 一：动态字符串

Redis构架了一种名为简单动态字符串（simple dynamic string,SDS）的抽象类型，作为自己的默认字符串.除了保存数据之外，还可用作缓冲区：AOF模块中的AOF缓冲区，输入缓冲区。
### SDS的定义
```c
sruct sdshdr {
	//记录buff数组中已使用的字节制度程度，不包括'\0'，即字符串程度
	int len;
	//记录未使用字节数量
	int free;
	//字节数组
	char buf[];
}
```
- 遵循C字符串空字符结尾惯例，'\0'的一字节空间不在计算范围内。
- 直接重用了一部分C字符串的函数，例如打印函数（printf）
###  SDS的特点
- C字符串：
	- 使用长度为N+1的字符数组，以'\\0'结尾，不能满足Redis对字符串安全性，效率以及功能方面的要求，字符串长度与底层字符数组空间相关联
	- 本身不记录自身的长度，获取自身长度需要遍历整个字符数组，时间复杂度O(n)。
	- 不记录自身长度还会导致容易导致缓冲区溢出![Cstring缓冲区溢出.png](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture/202305251026452.png)
		- 若在djccc后面插入字符串，会默认空间足够，导致覆盖别的字符串对象
	- 内存重分配次数比较多，每次增长或缩短买都会进行一次内存重分配操作。
	- 二进制不安全
- SDS：
	- 常数复杂度获取字符串长度
		- 因为结构体内有一个len属性记录了SDS的长度，每次字符串修改后都会自动修改len，这样可以O(1)复杂度获取字符串长度。
	- 杜绝缓冲区溢出
		- 结构体中有一个len和free属性，当需要修改字符串对象时，会让len与free相加，与要修改的字符串长度比较，若足够则在原本基础上修改，否者重新开辟一段内存空间，拓展对象空间。（包括空间预分配）
	- 减少修改字符串时带来的内存重分配次数
		- 增长或缩短都可能会导致内存重分配操作：
			- 情景：
				- 若增长后的长度大于底层字节数组空间，需要内存重分配
				- 若缩短后不再使用那部分空间，由于没有修改数组，空间会一直占用，会产生内存泄漏
				- 若一般情况下不太经常修改程度可以介绍，但Redis频繁修改，所以要减少内存空间重分配的次数。
				- 有空间与分配和惰性空间释放两种策略。
			- 空间预分配
				- 拓展SDS空间之前会判断未使用空间（free）是否足够，若足够，则不需要拓展。
				- 对SDS进行空间拓展的时候，不进会分配所修改必须要的空间，还会分配未使用的空间。
				- 若SDS修改后的长度（即len）将小于1MB，那么将分配与len等长的空间，即len=free，若大于等于1MB，会分配1MB未使用空间，即free=1MB。
			- 惰性空间释放
				- 缩短空间时，不会立即通过内存重分配回收未使用空间，而是会使用free来记录下来，以便在以后增长的时候利用，减少增长时导致的内存重分配，以及本次缩短导致的内存重分配。
				- 通时，SDS提供了相应的API，可以在有需要的时候释放SDS未使用的·空间，不需要担心惰性空间释放策略造成的内存浪费。
				- 另外可能会导致**内存碎片**问题，当SDS的未使用空间散布在SDS字符串的各个位置时，可能会出现无法分配连续内存块的情况，从而导致内存碎片。为了解决这个问题，Redis提供了内存碎片整理（memory defragmentation）功能，可以将SDS字符串的内容移动到连续的内存块中，从而消除内存碎片。但是，内存碎片整理需要消耗额外的时间和资源，因此需要在必要时才进行。
	- 二进制安全
		- buf是字节数组而不是字符数组，是二进制安全的。C的字符串字符数组必须符合某种二进制编码，只能保存文本文件。
		- 不是用这个数组来保存字符的，而是来保存一系列二进制数据，所以保存'\\0'等一些特殊字符都没关系，因为他是通过len而不是'\\0'来判读是否结束的，字节数组也可以保存一些特殊的数据如音频，视频等，不会对其中的数据做任何限制、过滤、或者假设，数据写入是什么样的，读取就是什么样的。
	- 兼容部分C字符串函数
		- 他在结尾用'\\0'是为了保存文本数据的那些SDS可以重用一部分<string.h>库定义的函数，例如对比函数（<string.h>/strcasecmp）、追加函数（将SD作为地个人股参数追加到C字符串后面。

## 二：链表

### 链表的定义：

当一个列表键包含了数量比较多的元素或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。 除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，redis服务器本身还用链表来构建客户端输出缓冲区。

### 链表的实现：

- 每个链表节点使用一个adlist.h/listNode结构来表示：
```c
typedef struct listNode {
	//前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```
- 多个listNode组成双端链表，通过adlist.h/list来持有链表
```c
typedef struct list {
	//表头节点
    listNode *head;
    //表尾节点
    listNode *tail;
    //节点复制函数
    void *(*dup)(void *ptr);
    //节点释放函数
    void (*free)(void *ptr);
    //节点对比函数
    int (*match)(void *ptr, void *key);
    //链表所包含的节点数量
    unsigned long len;
} list;
```
- Redis的链表实现的特性：
	- 双端： 有prev和next指针，获取某个节点的前置节点和后置节点的负责的均为O(1)
	- 无环：表头节点的prev和表尾结点的next均指向null，对链表的访问以NULL为终
	- 带表头和尾指针：通过list的head和tail指针，获取表头表尾复杂度尾O(1)
	- 带链表长度计数器：list里的len，对list持有节点数量进行统计。
	- 多态：链表节点使用void* 指针保存节点值，可以通过list结构中的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值

## 三：字典

### 字典的定义：

字典在Redis中应用非常广泛，Redis的数据库就是使用字典来作为底层实现的。此外还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。
### 字典的实现：

Redis的字典是使用哈希表作为底层实现，哈希表里面可以有多个哈希节点，每个哈希节点保存了一个键值对。

#### 哈希表：

- Redis字典使用的哈希表有dict.h/dictht定义
- table是一个数组，每个元素是指向dict.h/dictEntry结构体的指针，每个dictEntry结构保存了一个键值对
- size记录了哈希表的大小（table数组大小）
- used记录了哈希表目前已有节点的数量
- sizemask等于size-1，和哈希值一起决定了键应该放到table的哪个索引上

```c
typedef struct dictht{
	//哈希表数组
	dictEntry **table;
	//哈希表大小
	unsigned long size;
	//哈希表大小掩码，用于计算索引值
	//总是等于size-1
	unsigned long sizemask;
	//该哈希表已有的节点的数量
	unsigned long used;
} dictht
```
#### 哈希节点：

- k保存键，v保存值，值可以是一个指针、uint64_t整数或int64_t整数。
- next指向下一个哈希节点，当哈希值相同的时候，在dictht哈希数值（table）的指针进行头插法。以此来解决键冲突的问题。

```c
typedef struct dictEntry{
	//键
	void *key；
	//值
	union {
		void *val;
		uint63_t u64;
		int64_t s64;
	}v;
	//下一个哈希节点
	struct dictEntry *next;
}dictEntry;
```
#### 字典：

- Redis中字典由dict.h/dict结构表示
- type和privdata是为了针对不同类型的的键值对创建的多态字典而设置的。
- type是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为不同字典设置不同类型操作函数。
- privdata保存了需要传给那些特定函数的可选参数
- **ht**是一个包含了两个dictht哈希表的数组，一般情况下字典只使用ht[0]，ht[1]只有在对ht[0]进行rehash的时候会使用
- trehashidx用来标志rehash的进度，若没有进行rehash，则trehashidx为-1
```c
typedef struct dict{
	//
	dictType *type;
	//所有数据
	void *privdata;
	//哈希表
	dictht ht[2];
	//rehash索引
	//当rehash不在进行时，值为-1
	long trehashidx; /* rehashing not in progress if rehashidx == -1 */
}

typedef struct dictType {  
  uint64_t (*hashFunction)(const void *key);  
  void *(*keyDup)(dict *d, const void *key);  
  void *(*valDup)(dict *d, const void *obj);  
  int (*keyCompare)(dict *d, const void *key1, const void *key2);  
  void (*keyDestructor)(dict *d, void *key);  
  void (*valDestructor)(dict *d, void *obj);  
  int (*expandAllowed)(size_t moreMem, double usedRatio);  
  unsigned int no_value:1;  
  unsigned int keys_are_odd:1;  
  size_t (*dictEntryMetadataBytes)(dict *d);  
  size_t (*dictMetadataBytes)(void);  
  void (*afterReplaceEntry)(dict *d, dictEntry *entry);  
} dictType;
```
![字典数据结构.drawio.png](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture/202305261429753.png)

### 哈希算法及特点

- 将新的键值对要插入到字典里时，根据键值对的键计算出哈希值和索引值，然后根据索引值放到哈希数表数组的指定索引上。
	- hash=hash->type->hsahFunction(key);//计算哈希值
	- index=hash & dict->ht[x].sizemask;//计算索引值
	- 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Reis使用MurmurHash2算法来计算键的哈希值。
- 哈希冲突：
	- 当两个或多个减被分到同一个索引上时，称发生了哈希冲突
	- 通过头插法，把新的节点插入到链表的表头位置。
- rehash：
	- 随着操作的不断执行，哈希表保存的键值对会逐渐的增多或减少，为了让哈希表的负载因子维持在一个合理的范围内，当哈希表保存的键值对太多或太少时，对哈希表的大小进行相应的拓展或收缩（哈希表数组，dicht的dictENtry ** table大小）。
	- 哈希表索引过少的问题：
		- 内存利用率低：哈希表的索引空间不足时，会导致每个哈希桶（bucket）中的链表较长，增加了冲突和遍历的开销。这会占用更多的内存空间，并且影响了哈希表的性能。
		- 查询效率低：哈希表的索引空间不足时，查找特定键的效率较低。需要遍历较长的链表来找到目标键，增加了查找的时间复杂度。
	- 哈希表索引过多的问题：
		- 内存开销大：哈希表的索引空间过多会占用更多的内存空间，导致内存的浪费。
		- 内存碎片化：过多的索引空间可能会导致内存碎片化问题，使得内存的连续可用空间变少。
		- 
	- **rehash步骤：**
		1. 为字典的ht[1]哈希表分配空间，空间大小取决于要执行的操作以及[0]当前包含的键值对数量(即ht[0].used属性的值)
			-  若为拓展操作，这ht[1]大小为第一个大于等于ht[0].used* 2   的2^n的数
			-  若为收缩，这ht[0]大小为第一个大于等于ht[0].used   的2^n的数
		2. 将保存在ht[0]中所有键值对rehash到ht[1]上，在过程中，并没有重新分配内存或复制节点数据。节点仍然保持原有的地址和数据内容，只是将节点的指针从 `ht[0]` 桶中的位置修改为 `ht[1]` 桶中的位置。
		3. 当rt[0]包含的所有键值对转移到ht[1]之后，释放ht[1],将ht[1]设置为ht[0],并在ht[1]新创建一个空白的哈希表，为下次rehash做准备
- 执行拓展或收缩的条件：
	- 负载因子=哈希表已保存节点数/哈希表大小
	- 拓展（满足任意一个）：
		- 服务器目前没有执行BGSAVE或者BGREWRITEAOP命令。并且哈希表的负载因子大于等于1
		- 服务器正在执行BGSAVE或者BGREWRITEAOP命令并且哈希表负载因子大于等于5
		- 原因：在执行BGSAVE或者BGREWRITEAOP命令时，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用**写时复制**技术来优化子进程的使用效率，所以提供所需的负载因子来避免进行哈希拓展操作，这样可以避免不必要的内存写入，最大限度地节约内存。
	- 当负载因子小于0.1时进行收缩操作。
	- 关于写时复制：Redis在执行BGSAVE或BGREWRITEAOF命令时，会fork出一个子进程来生成rdb文件或重写AOF文件，采用写时复制技术，父子进程共享同一片内存区域，当任一进程企图对这片内存区域进行写入操作时，会把将要写入的那一部分内存页复制一份进行写入，其他内存页依旧共享。在字典扩容期间，父进程要迁移数据，不可避免的会有大量内存写入操作，为了减少内存页过多的复制，而提高了扩容的门限，这是出于节省内存考虑的。至于为什么Redis字典收缩时不用考虑写时复制？我认为原因有两个：一是收缩条件是键值对个数小于哈希表长度的10%，有意设置的这么低，就是为了不会造成过多的页分离；二是收缩操作完成会释放一部分内存，本身目的就是节省内存的。所以两个原因综合起来，不用考虑写时复制对收缩的影响。参考[[基础/小知识点/写时复制|写时复制]]
- **渐进式rehash**
	- rehash的动作不是一次完成的，而是分多次、渐进式的完成的。
		- 如果键值对过多，如果要一次性完成可能会造成庞大的计算量导致服务器在一段时间内停止服务。
	- 步骤：
		1. 为ht[1]分配空间，让字典同时拥有ht[1]和ht[2]两个哈希表
		2. 在字典中维护索引计数器变量rehashidx，用来记录rehash进度（每迁移完ht[0]的一个索引就会+1），将他设为0，表示rehash正式开始。
		3. 在rehash期间，每次对字典执行增删改查操作时，除了完成这些操作，还会顺带将ht[0]在hashidx索引上的键值对rehash到ht[0]中，当在rehashidx索引上的所有键值对都rehash过去后，rehashidx+1
		4. 最终所有键值对都会rehash到ht[1]上，这时**将新哈希表设为主哈希表，并释放旧哈希表**。后将rehashidx=-1。标志已经rehash完成。
	- 渐进式rehash的1好处：采用分而治之的方式，将rehash键值对所需的计算工作均摊到对字典每个增删改查操作上，从而避免了集中式rehash带来的庞大计算量
- 渐进式rehash执行期间的哈希表操作
	- 会同时使用ht[0]和ht[1],两个哈希表，所以在rehash过程中，增删改查会在两个表上操作。
		- 新增操作：直接将键值对插入到ht[1]上，保证ht[0]的结点不会增加；
		- 删除操作：同时在ht[0]和ht[1]两个哈希表上执行，避免漏删；
		- 修改操作：同时在ht[0]和ht[1]两个哈希表上执行，避免漏改；
		- 查找操作：先从ht[0]查，查不到的话再去ht[1]查；

## 四：跳跃表

### 跳跃表的定义：

跳跃表是一种有序地数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的

### 跳跃表的特点：

跳跃表支持平均O（logN），最坏O(n）负责的杜节点处=查找，还可以通过顺序性操作来批量处理节点。

在大多数情况下，跳跃表的效率可以与平衡树媲美，并且因为跳跃表的实现比平衡树更简单，所以有不少程序都使用跳跃表来代替平衡树

### 使用场景：

只在两个地方使用，一个是实现有序键集合·，另一个是在集群节点中作为内部数据结构，除此之外，跳跃表在Redis中没有其他用途。

如果一个有序集合包含的元素数量比较多或者有序键集合中元素成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。

### 跳跃表的实现：

跳跃表由server.h/zskiplist 和zskiplistNode定义，Node表示跳跃表节点，而zskiplist由于保存跳跃表节点的相关信息，比如节点数量，头指针，尾指针，最大高度。

头结点是一个32层的空节点，用来指向后面节点，默认跳跃表节点层高在1-32之间，分布是按幂分布，越高层概率越低。

![image-20230815105650149](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151056182.png)

- level表示层级数组，每一层都有下一个节点的地址以及跨度。
- 每个节点都有一个分值，各个节点的额对象必须是唯一的，而保存的分钟可以相同，所有节点是按各自的分值来排序的，若分值相同，后按对象在字典序中的大小；来进行排序。（字典序：基于ASCLL或者Unicode编排比较字符串的方法）

![image-20230815110513901](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151105945.png)

![image-20230815110554412](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151105461.png)

#### 跳跃表插入的实现：

- 插入的时候可以把跳表的每一层当做一个链表，从高到低进行插入。
- 高层跨度比较大，所以要插入的位置一定在高层插入位置或者它的右边
- 在高层找到插入位置后，在这个上一个节点的下一层继续往后遍历，找到找到本层插入位置，插入后继续在插入位置前一个节点的下一层执行插入，找到完成第一层的插入。

此外，查询和插入类似，只不过省去了插入的步骤，

删除也和插入步骤类似，保证每层·的链表都不会断掉。

## 五：整数集合

整数集合是集合键的底层实现之一，当一个集合只包含整数数值元素，并且这个集合数量不多时，Redis就会使用整数集合作为集合键的底层实现。

### 整数集合的实现：

![image-20230815111829681](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151118722.png)

整数集合(intset)是Redis用与保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复的元素。

- contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中安值的大小有序地排列，并且数组中不包含任何重复项。
- length属性记录了整数集合包含的元素数量，也即是contents数组长度。
- 虽然intset结构将content属性声明为int8_t类型的数组，但实际上contents数组并不保存任何int8_t类型的值，contents数组`真正的类型取决于encoding三星的值`

### 整数集合的升级：

当我们要将一个新元素添加到整数集合中，并且新元素的类型比整数集合现有的有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步：

1. 根据新元素的类型，拓展整数集合底层数组的空间大小，并且为新元素分配空间。
2. 将底层数组现有的所有元素都转换为与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性不变
3. 将新元素添加到底层数组里面。

参考书上内容：

![image-20230815114243255](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151142471.png)

> 触发升级的新元素比现有所有元素都长，所以他要么比现有所有元素大，要么小，即要么放最后，要么开头

- 升级的好处：
  - 提升灵活性
    - 通过自动升级来适应新元素，所以可以随意地将不同类型的整数添加到集合中，不必担心类型错误
  - 节约内存
    - 可以确保升级操作只会在需要时进行，可以尽量节约内存

> 整数集合不支持降级操作，一旦进行了升级，就会一直保存升级后的状态。

## 六：压缩列表

压缩列表是列表键和哈希键的底层实现之一。当一个列表键值包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

另外，当一个哈希键值包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

> 本质上是一个字节数组

### 压缩列表的实现：

#### 压缩列表的构成：

压缩列表是Redis为了节约内存而开发的，是由一系列特色编码的连续内存快组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。

![ziplist.drawio](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151317777.png)

| 属性    | 类型      | 长度  | 用途                                                         |
| ------- | --------- | ----- | ------------------------------------------------------------ |
| zlbytes | unint32_t | 4字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配或者基数按zlend的位置是使用 |
| zltail  | unint32_t | 4字节 | 记录压缩列表列表表尾节点距离压缩列表起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | unint16_t | 2字节 | 记录了压缩列表压缩列表包含的节点数量：这个属性小于unint16_MAX时表示数量，当大于时，需要遍历整个压缩列表来计算（溢出了就无法表示它的数量了 |
| entry   | 列表节点  | 不定  | 压缩列表包含的各个节点，节点长度有节点保存的内容决定         |
| zlend   | unint8_t  | 1字节 | 特色值OxFF（10进制255）,用于标记压缩列表的末端               |

### 压缩列表节点的构成：

![image-20230815144520046](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151445082.png)

每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是一下三种长度之一：

- 长度小于等于63(2^6-1)字节的数组
- 长度小于大于16383（2^14-1）字节数组
- 长度小于等于4 294 967 295 （2^32-1）字节的数组

而整数有以下六种长度：

- 4位长度，介于0-12之间的无符号整数
- 1字节长的有符号整数
- 3字节长的有符号整数
- int16_t类型整数
- int32_t类型整数
- int64_t类型整数

#### previous_entry_length:

以字节为单位，记录了压缩列表中前一个节点的长度

他的长度可以是一个字节或者五个字节：

- 如果前一个节点的长度小于254字节，那么previous_entry_length的长度为`1字节`：前一个节点的长度就保存在这一个字节里面
- 如果前一个节点的长度大于154字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为OxFE（10进制254），而之后的四个字节则用于保存前一节点的长度。

> 基于这一特性，程序可以通过指针运算，根据当前节点的起始位置计算前一个节点的起始位置，可以实现压缩列表从表位向表头的遍历。

#### encoding：

encoding记录了节点的content属性所保存的数据类型以及长度

一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；

一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；

![image-20230815144546814](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151445874.png)

#### content：

**content属性负责保存节点的值，值的具体类型由上一个字段encoding来决定。**

例如存储字节数组，00表示类型为字节数组，01011表示长度为11

![image-20230815144343687](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151443739.png)

存储整数值，表示存储的为整数，类型为int16_t

![image-20230815144354569](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151443612.png)

### 连锁更新：

添加一个节点后，可能会导致后面的节点的previous_entry_length需要增大，而后一个节点增大后，可能也超过了254，导致后面的节点继续增大，这样的情况叫做连锁反应。

> 除了添加新节点外，删除节点也可能会引发连锁更新

因为连锁股更新在最坏的情况需要对压缩列表执行N次空间重新分配操作，而每次空间重分配的最坏复杂度为O(n)，所以连锁更新的最坏复杂度为O(N^2).

- 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发，在实例中，这种情况并不多见
- 其次，即使出现连锁更新，但主要被更新的节点数量不多，就不会对性能造成任何影响：比如三五个节点进行连锁更新是绝对不对印象性能的。

## 七：对象

前面记录了Redis用到的所有主要数据结构，但它并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种上面的数据结构

通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象类型判断一个对象是否可以执行给定的命令，还可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。

除此之外，Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象时，这个对象锁占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库共享同一个对象来节约内存。

最后，Redis的对象带有访问时间记录信息，该信息可用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器销毁。

### 对象类型与编码：

Redis使用对象来表示数据库中的键和值，每次当我们在Redis中新创建一个键值对时，我们至少会创建**两个**对象，**一个作为键对象，一个作为值对象。**

> 底层是通过哈希表来存储键值对的，其中键和值都被表示为对象。Redis 的哈希表是一种散列表，它使用哈希函数将键映射到哈希桶（bucket），然后在桶内进行查找，以快速地检索值对象。

Redis中每个对象都是由一个RedisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性，encoding属性和ptr属性

```c++
typedef struct redisObject {
    //类型
    unsigned type:4;
    //编码
    unsigned encoding:4;
    //指向底层实现数据结构的指针
    void *ptr;
    //...
}robj;
```

![image-20230815153727698](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151537746.png)

#### 类型：

对象的type属性记录了对象的类型，这个属性的值可以是下面表格中的常量中一个

| 类型常量     | 对象名称     | TYPE命令的输出 |
| ------------ | ------------ | -------------- |
| REDIS_STRING | 字符串对象   | "string"       |
| REDIS_LIST   | 列表对象     | "list"         |
| REDIS_HASH   | 哈希对象     | "hash"         |
| REDIS_SET    | 集合对象     | "set"          |
| REDIS_ZSET   | 有序集合对象 | "zset"         |

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希独享、集合对象、有序集合对象中的一种，因此：

- 我们称呼一个数据库键位“字符串键”时，我们指的是`这个数据库键所对应的值为字符串对象`
- 同理，我们称一个键为XX时，指的是`这个键所对应的值为XX对象`

#### 编码和底层实现：

对象的ptr指针指向对象的底层数据结构，而这些数据结构由对象的encoding属性决定。

encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为底层实现，这个属性的值可以是下面列表中的常量：

| 编码常量                  | 编码所对应的底层数据结构   |
| ------------------------- | -------------------------- |
| REDIS_ENCODING_INT        | long类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字符串             |
| REDIS_ENCODING_HT         | 字典                       |
| REDIS_ENCODING_LINKEDLIST | 双端链表                   |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                   |
| REDIS_ENCODING_INTSET     | 整数集合                   |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典               |

每种类型的对象都至少使用了两种不同的编码，如下

> 使用OBJECT ENCODING 可以查看一个数据库键的值对象的编码

![image-20230815161756208](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151617308.png)


| 类型         | 编码                      | 对象                                           |
| ------------ | ------------------------- | ---------------------------------------------- |
| RESID_STRING | REDIS_ENCODING_INT        | 使用整数值实现的字符串对象                     |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | 使用embstr编码的简单动态字符串实现的字符串对象 |
| REDIS_STRING | REDIS_ENCODING_RAW        | 使用简单动态字符串实现的字符串对象             |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的列表对象                     |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 使用双端链表实现的列表对象                     |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的哈希对象                     |
| REDIS_HASH   | REDIS_ENCODING_HT         | 使用字典实现的哈希对象                         |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 使用整数集合实现的集合对象                     |
| REDIS_SET    | REDIS_ENCODING_HT         | 使用字典实现的集合对象                         |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的有序集合对象                 |
| REDIS_ZSET   | REDIS_ENCODING__SKIPLIST  | 使用跳跃表和字典实现的有序集合对象。           |

通过encoding属性来设定对象和所使用的编码，而不是特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。

例如：在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现

- 因为压缩列表比双端链表更节约内存，并且在元素数量比较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到内存中

- 随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将地城实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面

其他对像也会通过这种使用多种敢不同的编码来进行类似的优化

### 1. 字符串对象

> 字符串对象是五种类型中唯一一个会被其他四种对象嵌套的对象

字符串对象的编码可以是int、raw、embstr。

- 如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象将会保存在字符串对象结构的ptr属性里面（将void* 转换成long），并将`字符串对象`的编码设置为`int`。 
- 如果字符串对象保存的是一个字符串值，，并且这个字符串值的长度大于39字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw
- 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值
- 可以用long double类型表示的浮点数在Redis中也是作为字符串来保存的，如果要保存一个浮点数到字符串对象里面，那么程序会先将这个浮点数`转换为字符串值`，后保存所得的字符串值。
  - 有时候需要将保存的值转换为浮点对象后执行某些操作（加减乘除），然后将执行结果转换为字符串值，继续保存在字符串对象里面。   



- embstr编码：

![Redis 源码解析 6：五大数据类型之字符串 - 1024搜-程序员专属的搜索引擎](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151734728.png)

存储string类型。分配连续内存，性能较好

```c++
// 由源码知，创建embstr字符串对象只分配一次空间，且是连续的。
robj *createEmbeddedStringObject(const char *ptr, size_t len) {
    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
    struct sdshdr8 *sh = (void*)(o+1);

    o->type = OBJ_STRING;
    o->encoding = OBJ_ENCODING_EMBSTR;
    o->ptr = sh+1;
    o->refcount = 1;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
    } else {
        o->lru = LRU_CLOCK();
    }

    sh->len = len;
    sh->alloc = len;
    sh->flags = SDS_TYPE_8;
    if (ptr == SDS_NOINIT)
        sh->buf[len] = '\0';
    else if (ptr) {
        memcpy(sh->buf,ptr,len);
        sh->buf[len] = '\0';
    } else {
        memset(sh->buf,0,len+1);
    }
    return o
```

- raw编码：

![Redis内存优化——String类型介绍及底层原理详解_redis对string做的优化_Mr___Ray的博客-CSDN博客](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308151735880.png)

string类型。分配两次内存，一次分配robj，一次分配sdshdr8，内存不一定连续，性能低于embstr，但是，按照设计可存储更多的数据。

```c++
robj *createRawStringObject(const char *ptr, size_t len) {
    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
}

//第一次分配内存空间，Object的内存空间
robj *createObject(int type, void *ptr) {
    robj *o = zmalloc(sizeof(*o));
    o->type = type;
    o->encoding = OBJ_ENCODING_RAW;
    o->ptr = ptr;
    o->refcount = 1;

    /* Set the LRU to the current lruclock (minutes resolution), or
     * alternatively the LFU counter. */
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
    } else {
        o->lru = LRU_CLOCK();
    }
    return o;
}

//第二次分配内存空间  sds的
sds sdsnewlen(const void *init, size_t initlen) {
    void *sh;
    sds s;
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
    int hdrlen = sdsHdrSize(type);
    unsigned char *fp; /* flags pointer. */

    sh = s_malloc(hdrlen+initlen+1);
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        memset(sh, 0, hdrlen+initlen+1);
    s = (char*)sh+hdrlen;
    fp = ((unsigned char*)s)-1;
    switch(type) {
        case SDS_TYPE_5: {
            *fp = type | (initlen << SDS_TYPE_BITS);
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            sh->len = initlen;
            sh->alloc = initlen;
            *fp = type;
            break;
        }
    }
    if (initlen && init)
        memcpy(s, init, initlen);
    s[initlen] = '\0';
    return s;
}

```

​	embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构，而。raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来哦分配一块连续空间，空间中依次包含redisObject和sdshdr两个结构。如下面两图所示

​	embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处

- embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
- 释放embstr编码的字符串对象只需调用一次内存双方函数，而释放raw编码的字符串对象需要两次
- 因为embstr编码的字符串对象所有数据保存在一块连续的内存里面，所以这种编码的字符串对象比起raw可以更好地利用`缓存(计组缓存cache，读取内存先把内容读到缓存中，速度更快)`带来的优势

### 2.列表对象

列表对象的编码可以是ziplist或者linkedlist。

ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列节点（entry）保存了一个列表元素。

linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个`字符串对象`，而每个字符串对象都保存了一个`列表对象的元素`。

> 注意：linkedlist编码的列表对象在底层的双端链表结构中包含了多种字符串对象。这种嵌套字符串的行为在字符串对象之外的对象中均会出现

**编码转换**

当列表对象可以同时满足一下两个条件时，列表对象会使用ziplist：

- 列表对象保存的所有字符串元素的对象都小于64字节
- 列标对象保存的元素数量小于512个

不能满足这两个条件的列表对象需要使用linkedlist编码。（可以在配置文件中修改）

对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任一个不能被满足时，就会被执行，原本保存在压缩列表中的所有列表元素都会被转移并保存到双端链表里面，对象的编码会由ziplist变为linkedlist。

### 3.哈希对象

哈希对象的编码可以是ziplist或者hashtable。

ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：

- 保存了统一键值对的两个节点总数紧挨在一起，包存键的节点在前，保存值的节点在后。
- 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希表对象中的键值对会被放在压裂列表的表尾方向。

![image-20230815222154346](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308152221396.png)

hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：

- 字典的每个键都是一个字符串对象，对象中保存了键值对的键；
- 字典的每个值都是一个字符串对象，对象中保存了键值对的值。

![image-20230815215237867](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308152152919.png)

**编码转换**

当哈希对象可以同时满足一下两个条件时，哈希对象使用ziplist编码：

- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
- 哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。

> 关于数量的限定：
>
> - 压缩列表无法像传统的哈希表一样使用哈希函数来确定键的存储位置，因为 ziplist 的结构不适合这种方式。ziplist 使用线性搜索来查找键值对。当插入一个新的键值对时，ziplist 会从头到尾遍历键值对，然后判断是否已经存在相同的键
> - 因此吗，若长度过大，复杂度会大大提高，所以ziplist作为哈希表的底层实现只在数量比较少的时候使用。

### 4.集合对象

集合对象的编码可以是intset或者hashtable。

intset编码的集合使用整数集合作为底层实现，集合对象包含所有元素都被保存在整数集和里面

hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。

编码的转换

当集合对象可以同时满足一下两个条件时，对象使用intset编码：

- 集合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过512个；

不能满足这两个条件的集合对象需要使用hashtable编码

### 5.有序集合对象

有序集合的编码可以是ziplist或者skiplist

`ziplist`编码的有序结合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的·压缩列表节点来保存，第一个节点保存元素的成员，而第二个节点则保存元素的分值

压缩列表内的集合元素按分值从小到大进行排序，分值小的元素被放在靠近表头的位置，而分值较大的元素则被放置在靠近表尾的位置。



![image-20230815221025630](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308152210671.png)

![image-20230815221119875](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308152211916.png)

`skiplist`编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：

```c++
typedef struct zset{
    zskiplist *zsl;
    dict *dict;
} zset;
```

zset结构中，zsl跳跃表按分值从大到小保存了所有结合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素成员，而跳跃表节点的socre属性则保存了元素的分值。通过这跳跃表，程序可以对有序集合进行范围型操作

除外，zset结构中的dict字典为有序集合创建了一个成员到分值的映射，字典的每一个键值对都保存了一个集合元素：字典的键保存元素成员，值保存了元素的分值，程序可以通过O（0）复杂度通过元素来获取分值，后通过分值在跳跃表中查询

有序集合每个元素的成员都是一个`字符串对象`，而每个元素的`分值都是一个double类型`的浮点数。虽然zset结构同时使用跳跃表来保存有序集合的元素，但是这两张数据结构都是`通过指针来共享元素的成员和分值的`.

> 为什么有序链表需要同时使用跳跃表和字典来实现？
>
> 理论上两种都可以分别使用，但性能上比起同时使用字典和跳跃表都会有所降低。
>
> 例如，**只用字典**的话虽然可以O(1)复杂度查找成员对象，但是字典是无序的，所以如果进行范围型操作，则需要对所有元素进行排序，完成这种排序至少需要O(NlogN)时间复杂度，以及额外的O(N)内存空间。
>
> **只用跳跃表**的话，那么根据成员查找分值这一操作将会从O（1）上升至O（N），**因为没有分值，在只能从头遍历，寻找元素对象。**
>
> 
>
> 在有序集合中，跳跃表用于实现成员的排序和范围查找操作，而字典用于存储成员与分值之间的映射关系。这样一来，在进行根据成员查找分值这样的操作时，通过字典可以在常数时间内获取到对应的分值，而不需要进行线性搜索。所以，有序集合的结构设计充分利用了跳跃表和字典的优势，以提供高效的操作。

编码的转换，

当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

- 有序集合保存的元素数量小于128个
- 有序集合保存的所有元素的长度都小于64字节

否则有序集合对象将使用skiplist编码。 

### 类型检查与命令多态

Redis中用于操作键的命令基本可以分为两个类型

1. 可以对任何类型的键执行。比如：DEL名，EXPIRE命令，RENAME命令
2. 只能对特定类型的键执行比如：
   - SET、GET、APPEND、STRLEN等命令只能对字符串键执行
   - HDEL、HSET、HGET、HLEN等只能对哈希键执行

#### 类型检查的实现

为确保只有指定类型的键可以执行指定类型的命令，在执行一个类型特定的命令前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。

类型特定的命令所进行的检查是通过RedisObject结构的type属性来实现的：

- 在执行一个类型的特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所虚的类型，如果是的话，服务器就会对键这些词那个指定的命令
- 否则，服务器将拒绝执行命令，并给客户端返回一个类型错误。

#### 多态命令的实现

Redis除了会判断特定的命令是否可以执行外，还可以根据值对象的`编码方式`，选择正确的代码来执行命令

例如对列表对象执行LLEN命令，其中列表对象有ziplist和linkedlist两种编码，其中分别有对应的api来实现命令。所以执行操作时，还会根据键的值对象所使用的编码来进行正确的LLEN操作。

- 如果为ziplist编码，将会使用ziplistLen函数
- 如果为linkedlist编码，将会使用listLength函数

从面向对象的角度，可以认为LLEN是多态的。

![image-20230816082849259](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308160828338.png)

> 实际上，也可以将DEL、EXPIRE、TYPE等命令也称为多态命令，因为无论输如的键是什么类型，这些命令都可以正确地执行
>
> DEL、EXPIRE等命令与LLEN等命令的区别在于：
>
> - 前者是基于类型的多态——一个命令可以处理多种不同类型的键
> - 后者是基于编码的多态——一个命令可以同时用于处理多种不同的编码

### 内存回收

因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息由RedisObject结构的refcount属性记录：

```c
typedef struct redisObject{
    //...
    //引用计数
    int refcount;
    //...
}robj;
```

对象的引用计数信息回随着对线的使用状态而不断变化：

- 当创建一个新对象时，引用计数的值会被初始化为1
- 当对象被一个新的程序使用时，他的引用计数值会增加1
- 当对象不在被一个程序使用时，他的引用计数值会减一
- 当对象的引用计数值变为0时，对象所占用的内存就会被释放。

> 对象的生命周期可以划分为：创建对象、操作对象、释放对象三个阶段

### 对象共享

**除了用于实现引用计数内存回收机制外，对象的引用计数属性还带有对象共享的作用。**

例如：

如果键A创建了一个包含整数100的字符串对象作为值对象，如果键B也要创建一个包含了整数值100的字符串对象作为值对象，那么服务器有以下两种选择：

1. 为键B新创建一个包含整数值100的字符串对象
2. 让键A和键B共享同一个字符串对象

显然第二种方法更节约内存。

![image-20230816093227331](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308160932397.png)

![image-20230816093320647](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308160933693.png)在Redis中，让很多键共享同一个值对象需要执行以下两个步骤：

1. 将数据库键的值指向一个现有的值对象
2. 将被共享的对象引用计数加一

**以上为较早版本**

新版本不会++；

新版本默认只有0-9999会被共享，

所以，超过10000的都不会被共享，每个对象都是单独的RedisObject。

0-9999的数字，它的refcount是一个固定的数字，不会++，仅仅是使用一个固定的MAX常量来表示它是共享号码。

demo不会+1 [共享对象refcount不会++](https://github.com/redis/redis/issues/12491)

> 目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象

这些共享对象`不仅只有字符串键可以使用`,那些在`数据结构中嵌套了字符串对象的对象`(linkedlist编码的列表对象、hashtable编码的哈希对象，hashtable编码的集合对象，以及zset编码的有序集合对象)都可以使用这些共享对象。

> 为什么Redis值对包含整数值的字符串对象进行共享
>
> ![image-20230816100118130](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308161001928.png)
>
> 当服务器考虑将一个共享对象设置为键的值对象时，需要先检查给定的共享对象和目标对象是否完全相同，只有完全相同时，才会将共享对象作为键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否完全相同所需的负责的就越高，消耗的cpu时间也会越多
>
> - 如果共享对象保存的时整数值的字符串对象，那么验证操作的复杂度为O(1);
> - 如果共享对象时保存字符串值的字符串对象，那么验证操作的复杂度为O(1)
> - 如果共享对象是包含了多个值（或者对象）的对象，比如列表对象或者哈希对象，那么验证操作的复杂度将会是O(N^2).
>
> 因此，尽管共享更复杂的对象可以节约更多的内存，但受到的CPU时间限制，Redis只对包含整数值的字符串对象进行共享。

### 对象的空转时长

除了前面介绍过的type、encoding、ptr和refcount四个属性外，RedisObject还有一个lru属性，该属性记录了对象最后一次被命令程序访问的时间

![image-20230816112313515](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202308161123564.png)

OBJECT IDLETIME 命令可以抖音给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。

> OBJECT IDLETIME  命令的实现比较特殊，这个命令在访问键的值对象时，不会修改lru属性

除了可以被OBJECT IDLETIME 命令打印出来之外，键的空转时长还有另外一项作用：如果服务器开启了maxmemory选项，并且服务器用于内存回收算法为volatile-lru或者allkeys-lru，那么当服务器占用数超过maxmemory选项所设置的上限值时，空转时长比较高的那部分键互优先被服务器释放，从而回收内存。
