# 过期删除策略和内存淘汰策略

## 过期删除策略

### 1. 设置过期时间的命令

先说一下对 key 设置过期时间的命令。 设置 key 过期时间的命令一共有 4 个：

- `expire <key> <n>`：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期；
- `pexpire <key> <n>`：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。
- `expireat <key> <n>`：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；
- `pexpireat <key> <n>`：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）

当然，在设置字符串时，也可以同时对 key 设置过期时间，共有 3 种命令：

- `set <key> <value> ex <n>` ：设置键值对的时候，同时指定过期时间（精确到秒）；
- `set <key> <value> px <n>` ：设置键值对的时候，同时指定过期时间（精确到毫秒）；
- `setex <key> <n> <valule>` ：设置键值对的时候，同时指定过期时间（精确到秒）。

如果你想查看某个 key 剩余的存活时间，可以使用 `TTL <key>` 命令。

### 2.判断是否过期

会把key带上过期时间存到过期字典中

```c++
typedef struct redisDb {
    dict *dict;    /* 数据库键空间，存放着所有的键值对 */
    dict *expires; /* 键的过期时间 */
    ....
} redisDb;
```

上面的expires就是过期字典的指针

- 过期字典的key是一个指针，指向键对象
- 过期字典的value是一个longlong整数，保存了key的过期时间

![img](https://cdn.jsdelivr.net/gh/ddddjc/djcPicture@master/202312112213576.png)

当查到某个key时，Redis首先检查key是否在过期字典中

- 不在，则正常读取键值
- 存在，获取该key的过期时间，然后与当前系统时间对比，如果系统时间大，那么就是没过期，否则过期。

### 3过期删除策略

- 定时删除
- 惰性删除
- 定期删除

#### 1. 定时删除

在设置key过期时间是，同时创建一个定时事件，当时间到达时，由事件处理器自动执行key的删除操作。

优点：对内存是友好的，可以保证key会被尽快的删除，内存尽快释放

缺点：对CPU不友好，在过期key较多的情况下，删除过期key可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间紧张的情况下，将CPU时间用于生成和当前任务无关的过期键上，无疑对服务器的响应时间和吞吐量造成影响

#### 2. 惰性删除

不自动删除，当访问key时，检测是否过期，如果过期则删除

优点：对CPU友好，只有访问时才检测是否过期，使用很少的系统资源

缺点：对内存不友好，如果有些数据不常用，且过期了，则不会自动清理，容易造成内存浪费。

#### 3. 定期删除

每隔一段时间**随机**从数据库中抽取一定数量的key，删除其中过期的key。

优点：通过限制生成操作的时长和频率，减少操作对CPU的影响，同时删除部分过期的数据减少了过期键对空间的无效占用

缺点：

- 内存清理方面没有定期删除效果好，同时又没有惰性删除咱用的系统资源少
- 难以确定操作执行的时长和频率，太频繁则接近于定时删除，太少则接近于惰性删除

### 4.Redis的过期删除策略

**采用惰性删除+定期删除配合使用**

Redis定期删除的方案：

**每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。**

#### 1.时间间隔：

默认是每秒进行10次过期检查数据库，可以在Redis的配置文件中配置。单位是hz

#### 2随机抽查的数量：

写死在代码中，数量是20.

>  在设置的时间范围内

在一个循环中删除，如果过期键低于5，则停止，否则则继续（过期键维持在小于25%的数量）

伪码：

```c
do {
    //已过期的数量
    expired = 0；
    //随机抽取的数量
    num = 20;
    while (num--) {
        //1. 从过期字典中随机抽取 1 个 key
        //2. 判断该 key 是否过期，如果已过期则进行删除，同时对 expired++
    }
    
    // 超过时间限制则退出
    if (timelimit_exit) return;

  /* 如果本轮检查的已过期 key 的数量，超过 25%，则继续随机抽查，否则退出本轮检查 */
} while (expired > 20/4); 
```

![img](https://cdn.jsdelivr.net/gh/ddddjc/djcPicture@master/202312112213134.png)

## 内存淘汰策略

[13. Redis内存淘汰策略 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/637508650)

> 内存淘汰是指当程序运行时，内存空间不足以容纳新的数据时，需要选择一种方式来释放一部分已经占用的内存空间，以便为新的数据流出空间。这种释放内存的过程称为内存淘汰。
>
> 内存淘汰主要是只当Redis的内存达到了设定的实现时，为了给新的数据留出空间，淘汰掉一部分数据。Redis提供了多种内存淘汰策略，以应对不同的使用场景。如果不能正确地配置内存淘汰策略，可能会导致重要数据的丢失

### 1. noeviction

当内存不足以容纳新的数据时，新的写操作会被拒绝，Redis会返回错误。这样可以保证已有数据的安全，同时操作开发或运维人员也会得到明确的信号去增加Redis的内存或者寻找其他解决方案

> 在对数据完整性和可靠性有严格要求，不允许任何形式数据丢失的场景中，应选择**noeviction**作为Redis的内存淘汰策略

### 2. allkeys-lru

当内存不足以容纳新的数据时，先淘汰最长时间未被使用的数据。意味着那些经常被访问的数据（热点数据）会被保存。

> 对于数据访问有热度不通用的场景中适用，比如电商系统

### 3. volatile-lru

优先淘汰设置了过期时间且最近最少被使用的键

> 某些场景会预料到一些数据会在一定时间内被访问频繁，而之后不频繁，且过期，只不过是提前被冷落的数据给他淘汰掉

### 4. allkeys-random

在所有键中随机选择进行淘汰，不关心是否设置了过期时间和被访问的频率或者时间。

由于所有数据都有可能被随机淘汰，就避免了某些数据因访问频率底而频繁淘汰，在一定程度上保证了所有数据在Redis中的生存机会均等。同时，这种策略的实现和执行效率都相对较高

> 这种策略可能导致一些主要输意外丢失，因此在选择使用这种策略时，应确保可以容忍数据丢失，或者有其他机制（如持久化或备份）来放置数据丢失带来的影响
>
> 在所有键的访问频率和模式无法预测且每个键的价值差异不大的确情况下使用

### 5. volatile-random

这种策略会从已设置过期时间中的键中随机选择一个进行删除，确保了那些主要的、永久的数据（比如用户账号，系统设置等）不会被删除。

**好处：**

1. `volatile-random` 有助于保持新闻内容的新鲜性。因为这种策略会随机地从已设置过期时间的键中选择一个进行删除，这就意味着那些过时的或不再相关的新闻更有可能被删除。
2. 这种策略也可以提供一种权衡，防止所有新闻在内存不足时被一次性全部删除，因为它是随机选择的。

但是，需要注意的是，`volatile-random` 策略并不考虑键被访问的频率或者时间。如果你的系统中某些新闻比其他的更热门，那么你可能需要选择不同的淘汰策略，比如 `volatile-lru`。

> 适用在预料到某些信息可能在某个时间后被冷落

### 6. volatile-ttl

> ttl：Time to live

优先删除最快过期的键

好处：

1. 有效地保证了广告的有效期。因为这个策略会优先删除那些快要过期的广告，这就避免了过期广告被展示出来。
2. 节约内存资源。因为只有设置了过期时间的广告会被考虑删除，所以这种策略可以确保那些仍然有广告预算，还没有到结束日期的广告不会被提前删除

> 不过，这种策略可能不适合那些广告展示次数和用户互动频率更高的场景，因为它并不考虑这些因素，可能会删除一些用户互动率很高的广告。对于这种场景，可能需要选择其他更适合的淘汰策略。

### 7. allkeys-lfu

FLU（Least Frequency Used）优先删除最少使用的键

该策略会计算每个键的使用频率，并删除使用频率最低的键

优点：

1. 可以确保热门信息被保存
2. 可以有效地利用有限的内存资源，将内存用于那些最需要的地方。

> 无法应对那些突然变得热门的商品，比如搞活动，冷门视频变热门。

### 8. volatile-lfu

仅对设置了过期时间的键进行lfu淘汰

那些未设置过期时间的重要数据将不会被淘汰

> 缺点，对每个键都需要设置过期时间，瑞国忘了设置，将永远不会被淘汰。

### LFU和LRU

LFU（Least Frequently Used，最少使用）和LRU（Least Recently Used，最近最少使用）都是Redis的内存淘汰策略。它们各自有一些特定的使用场景，而是否"更好"取决于具体的应用需求和使用情况。

LRU：LRU策略基于数据的"年龄"或最后访问时间进行淘汰。这种策略认为，如果一个数据在最近一段时间内没有被访问过，那么在将来也不太可能被访问。因此，当内存需要释放时，Redis会选择最长时间未被访问的数据进行淘汰。

LFU：LFU策略则基于数据的使用频率进行淘汰。它认为，如果一个数据的访问频率较低，那么在将来被访问的可能性也较低。因此，当内存需要释放时，Redis会选择访问频率最低的数据进行淘汰。

以下是LRU和LFU的一些优点：

LRU的优点：

1. 对于访问模式较为均匀的场景，或者历史访问模式能较好反映未来访问模式的场景，LRU效果较好。因为它能确保最近使用过的数据能够保留在内存中。

LFU的优点：

1. 对于访问模式存在明显热点的场景，LFU能更好地保留热点数据，提高缓存命中率。因为它优先淘汰访问频率低的数据。

至于选择哪种策略，需要基于你的应用特性和需求进行考虑。如果你的应用访问模式较为均匀，或者最近访问过的数据有较大可能性在未来被再次访问，那么LRU可能更适合你。如果你的应用访问模式存在明显的热点，那么LFU可能更优。如果你无法确定，你可以在实际环境中对这两种策略进行测试，看哪种策略能提供更高的缓存命中率。