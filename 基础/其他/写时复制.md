**1、写时复制简介**
源自[写时复制技术详解(COW) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/452676926)
**写时复制**（**Copy-on-write**，简称**COW**）是一种计算机[程序设计](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E7%25A8%258B%25E5%25BC%258F%25E8%25A8%25AD%25E8%25A8%2588)领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是[透明](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%2580%258F%25E6%2598%258E)的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。

**2、用途:**

### 虚拟内存管理中的写时复制

一般把这种被共享访问的页面标记为只读。当一个task试图向内存中写入数据时，[内存管理单元](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2586%2585%25E5%25AD%2598%25E7%25AE%25A1%25E7%2590%2586%25E5%258D%2595%25E5%2585%2583)（MMU）抛出一个异常，内核处理该异常时为该task分配一份物理内存并复制数据到此内存，重新向MMU发出执行该task的写操作。

### 数据存储中的写时复制

[Linux](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/Linux)等的文件管理系统使用了写时复制策略。

[数据库](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593)服务器也一般采用了写时复制策略，为用户提供一份snapshot。

### 软件应用中的写时复制

[C++标准程序库](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/C%252B%252B%25E6%25A0%2587%25E5%2587%2586%25E7%25A8%258B%25E5%25BA%258F%25E5%25BA%2593)中的[std::string](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/String_%28C%252B%252B%25E6%25A0%2587%25E5%2587%2586%25E5%25BA%2593%29)类，在C++98/C++03标准中是允许写时复制策略。但在[C++11](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/C%252B%252B11)标准中为了提高并行性取消了这一策略。GCC从版本5开始，std::string不再采用COW策略。

**3、写时复制详解**

COW是存储系统中使用的基本更新策略之一(还有就地更新（UIP）)。基本模式永远不会覆盖旧数据。使用COW策略更新数据块时，数据块被读入内存，进行修改，然后写入新位置，而旧数据则保持不变。由于COW永远不会覆盖旧数据，因此通常用于防止由于本地文件系统中的系统崩溃而导致数据丢失,COW更新策略已在存储系统中广泛使用

但是COW引入了令人不愉快的递归更新过程。文件系统可以看作是由磁盘块组成的大树，当使用COW策略修改叶块时，还需要修改其父节点以更新修改后的子块的新位置。此更新过程将递归进行，直到到达根块为止，该根块可以在磁盘上的固定位置进行更新。我们将这样的过程定义为递归更新。递归更新可能会导致存储系统出现多种副作用，例如WRITE放大，I / O模式变更和性能下降

**缺点:**

1. 写_放大：_递归更新可能会导致写放大，比如应用程序只需要修改一个叶子数据块F 但是，递归更新导致总共修改了四个父级节点（F->D->A->Root）。实际刷新的数据高达4 × 请求的数据。实际上，由于在这种情况下忽略了由块分配引起的递归更新，因此修改的块数量可能会更高。
2. _性能_下降_：_ WRITE放大会引入其他数据以进行写入，这最终可能会降低文件系统的性能。

**优点:**

1. _保护数据：_本地文件系统.由于有备份机制,不会因为文件系统崩溃导致大量甚至全部数据丢失.
2. _提高性能：_日志结构的文件系统，例如Sprite LFS,使用COW更新策略将访问模式从大量的小随机写入转换为单个大的顺序WRITE，从而利用了磁盘顺序I / O带来的高性能。
3. _在特殊介质上更新数据：_一次写入多次读取的介质，例如光盘，使用COW实施随机WRITE。闪存文件系统使用COW优化更新过程，这有助于提高WRITE性能并实现损耗均衡。

**4、fork和cow**

**cow是一种优化策略,fork是linux提供的创建新线程的方法,大多数的fork实现借用了cow策略来节省内存空间.**  
  
子进程和父进程继续执行fork之后的指令。子进程是父进程的复制品。例如，子进程获得  
父进程数据空间、堆和栈的复制品。注意，这是子进程所拥有的拷贝。父、子进程并不共享这  
些存储空间部分。如果正文段是只读的，则父、子进程共享正文段 ,  
现在很多的实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着
exec。作为替代，使用了在写时复制技术。这些区域由父、子进程共
享，而且内核将它们的存取许可权改变为只读的。如果有进程试图修改这些区域，则内核为有  
关部分，典型的是虚存系统中的“页” .
**fork细节**:一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。如果要求父、子进程之间相互同步，则要求某种形式的进程间通信
**总结**:所以在使用fork在借用cow策略实现时,其实父子进程会共享数据段、代码段、堆,而栈是父子进程独有的.

**5、vfork和fork**

vfork也用于创建一个新进程，而该新进程的目的是调用exec执行一个新程序。但vfork它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用 exec(exit)，于
是也就不会存访该地址空间。不过在子进程调用 exec或exit之前，它在父进程的空间中运行。  
这种工作方式在某些 U N I X的页式虚存实现中提高了效率（和fork类似即:在fork之后跟随 
exec，并采用在写时复制技术相类似） 。  
vfork和fork之间的另一个区别是:vfork保证子进程先运行，在它调用exec或exit之后父进  
程才可能被调度运行。 （如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会  
导致死锁。子进程在exec和exit之前其实运行在父进程的内存空间,所以子进程的数据操作其实是在修改父进程的对应数据.操作不当有可能导致进程崩溃.所以vfork之后建议立即执行exec或exit
tips：**UIP是将目标块读入内存，进行修改，然后在其原始位置写入磁盘（覆盖旧数据）**


