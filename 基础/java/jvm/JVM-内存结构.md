**JVM运行时数据区**

![image-20230717144321284](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202307171443358.png)

根据JVM规范，JVM运行时区域大致分为 方法区、堆、虚拟机栈、本地方法栈、程序计算器 五部分

# 1. 程序计数器

### 1.1 定义

Program Counter Register 程序计算器（寄存器）

- 作用：记住下一条jvm指令的执行地址
- 特点
  - 是线程私有的
  - 不会存在内存溢出

# 2. 虚拟机栈

![image-20230717161546743](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202307171615816.png)

方法区，栈，堆之间的关系

## 2.1 定义

Java Virtual Machine Stacks (Java虚拟机栈)

- 每个线程运行时需要的内存空间。线程之间是独立的，称为虚拟机栈
- 每个栈由多个栈帧（Frame）组成 
  - 栈帧：线程运行时每个方法需要的内存空间，包括 参数，局部变量，返回地址。

- 每个方法只能有一个活动栈帧，对应着当前正在执行的那个方法（类似于栈顶元素）

  - 需要运行方法时，使方法产生栈帧，进入栈，运行完出栈

  - 进栈出栈和数据结构类似

问题分析

- 垃圾回收是否会涉及栈内存 
  - 不会，栈内存主要用于存储局部变量、方法调用和线程执行状态等信息。他们的生命周期与方法的执行周期相联。当方法执行结束或线程退出时，栈内存中的数据会自动释放
  - 垃圾回收主要关注的是对内存
- 栈内存分配越大越好吗
  - 不会影响运行效率，反而可能会使线程数目变少
- 方法内局部变量是否线程安全
  - 主要看对其他线程是否共享。局部变量是否逃离了方法的作用范围。
  - 如果局部变量引用了对象并逃离了作用范围 不安全

## 2.2 栈内存溢出 

抛出异常：StackOverflowError

- 栈帧过多导致栈内存溢出   （递归调用，循环引用） 
- 栈帧过大导致溢出（不常见）

## 2.3 线程运行诊断

1：cpu作用过多

定位：

- 用top定位哪个进程对cpu占用过高
- ps H -eo pid，tid，%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高，grep筛选）
- jstack 进程id
  - 可根据线程id找到有问题的线程，进一步定位到问题代码的源码行号

2：程序运行很长时间没有结果

- 使用jstack查看
- 查找是否产生死锁

# 3. 本地方法栈

Native Method Stracks

给本地方法线程的运行提供栈

- 本地方法：指使用其他编程语言如c、c++编写的方法，可以通过java本地接口调用并与Java代码进行交互
- 本地方法栈与java虚拟机栈类似，但用于执行本地方法的栈帧而不是java方法。每个线程都有自己的本地方法栈，他与java虚拟机栈一一对应。
- 有native声明，没有方法实现，间接调用本地方法，

# 4. 堆

## 4.1定义

**Heap 堆**

- 通过 new 关键字，创建对象都会使用堆内存
- 是JVM所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。

特点

- 它是线程共享的，堆中对象都需要考虑线程安全问题
- 有垃圾回收机制

## 4.2 堆内存溢出

1. 对象生命周期过长：如果创建的对象在程序执行期间一直存在，并且无法被垃圾回收器回收，那么堆内存中的对象数量将持续增加，最终导致堆内存溢出。这可能是由于对象被持续引用、缓存未释放、长时间运行的循环或内存泄漏等原因引起的。
2. 内存泄漏：当对象不再需要时，没有正确释放对它们的引用，使得垃圾回收器无法回收它们。这种情况下，堆内存中的对象会逐渐积累，直到耗尽可用内存，导致堆内存溢出。
3. 大对象或数组：如果程序中创建了非常大的对象或数组，并且堆内存无法为其分配足够的连续空间，就会发生堆内存溢出。这种情况下，可能需要调整堆内存的大小或考虑优化对象的设计和使用方式。
4. 过多的线程或线程堆栈过大：每个线程都有自己的栈空间，如果创建了大量的线程，或者每个线程的堆栈空间设置得太大，都会消耗堆内存。当堆内存无法满足所有线程的需求时，就会导致堆内存溢出。
5. 内存资源不足：在某些情况下，系统的物理内存资源不足以满足应用程序的需求，即使堆内存大小设置得合理，也可能发生堆内存溢出。

要解决堆内存溢出问题，可以考虑以下方法：

- 调整堆内存大小：增加或减少堆内存的大小，使其适应应用程序的需求。
- 优化对象的生命周期和引用：确保对象在不再需要时能够被垃圾回收器正确释放。
- 检查内存泄漏：审查代码，找出可能导致内存泄漏的地方，并进行修复。
- 使用更高效的数据结构和算法：优化对象的设计和使用方式，减少内存占用。
- 减少线程数量或优化线程使用：合理管理线程数量，避免创建过多的线程，以减少对堆内存的消耗。
- 检查系统资源：确保系统的物理内存资源充足，如果有必要，可以考虑增加系统内存。

## 4.3堆内存诊断

1. jps工具
   - 查看当前系统中有哪些java进程
2. jmap工具
   - 查看堆内存占用情况
3. jconsole 工具
   - 图形界面，多功能检测工具，可连续检测

# 5. 方法区

## 5.1定义

是所有java虚拟机线程共享的区域。存储了跟类的结构相关的信息。

## 5.2 特点

方法区是JVM所有线程共享。

主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了区分，又通常叫做**非堆**。

## 5.3方法区内存溢出

产生过多类导致。一般使用物理内存，不容易导致溢出

- 1.8以前导致永久代内存溢出      -XX:MaxPermSize= 

- 1.8以后导致元空间内存溢出	 -XX:MaxMetaspaceSize= 

场景

- spring
- mybatis

## 5.4 常量池

- 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、产生类型、字面量等信息
- 运行时常量池：常量池是*.class文件中的，当类被加载，它的常量池信息就会放入运行时常量池，并把里面的字符地址变为真实地址。
  - jvm在执行某个类的时候，必须经过**加载、连接、初始化**，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。


## 5.5 StringTable特性

```java
	String s1="a";
	String s2="b";
	String s5="a"+"b"; //javac在编译期间的优化，确定为“ab”
//不是new的方法时，即不是String对象，而是常量，加载到常量池
	String s3=s1+s2; 
	==>s3=(new StringBuilder()).append(s1).append(s2).toString();//是字符串对象，放入堆中
```

字符串池：懒惰的，遇到一个字符串，若是没有在StringTable中，才会放入字符串池

- 常量池中的分层仅是符号，第一次使用到时才变为对象
- 历史串池的机制，来避免重复创建字符串对象
- 字符串变量拼接的原理是StringBuilder（1.8）
- 字符串常量拼接的原理是编译期优化
- 可以使用intern方法，主动将串池中还没有的字符串放入串池
  - 1.8将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则放入串池，会把串池中的对象返回
  - 1.8将这个字符串对象尝试放入串池，如果有则不会放入，如果没有则**复制一份**放入串池，会把串池中的对象返回

## 5.6 StringTable的位置

![image-20230718102448178](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202307181024299.png)

## 5.7 StringTable垃圾回收

## 5.8 StringTable 性能调优

**底层是hash表**

当字符串数量非常多时，

- 可以尝试将桶的个数调大。`-XX:StringTableSize=`,(哈希表桶打了，hash冲突产生的链表就短了，效率变高)
- 考虑将字符串对象是否入池：如果要new大量字符串且可能会有大量的重复内容，可以考虑new完字符串后 把字符串放入StringTable，后指向StringTable里面的字符串。

# 6. 直接内存

Direct Memory

- 常见于NIO操作时，用于数据缓冲区
- 分配成本比较高，但读写性能高
- 不受JVM内存回收管理

 分配和回收原理：

- 使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法
- ByteBuffer的实现内部类，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler 线程通过Cleaner的clean方法调用freeMemory来释放内存。
