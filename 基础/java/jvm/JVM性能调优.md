# JVM性能调优

在高性能硬件上部署程序，目前主要有两种方式

- 通过64为JDK来使用大内存
- 使用若干个32为虚拟机建立逻辑集群来利用硬件资源

## 使用64位JDK管理大内存

堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。如果堆内存为14G，那么每次Full GC 将长达数十秒。如果FullGC频繁发生，那么对于一个网站来说是无法忍受的。

对于用户交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大对的前提是有把握把应用程序的Full GC频率控制的足够低，至少要低到不会影响用户使用。

可能面临的问题：

- 内存回收导致的长时间停顿
- 现阶段，64位JDK的性能普遍比32位JDK低
- 需要保证程序只够稳定，因为这种应用要是产生对一次几乎就无法产生堆转储快照
- 相同程序在64位JDK消耗的内存一般比32位JDK大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的

## 使用32位JVM建立逻辑集群

在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。

考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留状态、热转移之类的高可用性能需求，也不需要保证每个虚拟机进程有觉得的负载均衡，因此使用无session负责的亲和式集群是一个不错的选择。我们仅仅需要保证集群具备亲和性，也就算均衡器按一定的规则算法（一般是SessionID分配）将一个固定的用户请求永远分配到固定的集群节点进行处理即可。

可能遇到的问题：

- 尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致IO异常
- 很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余
- 各个节点受到32为内存现在
- 大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。

