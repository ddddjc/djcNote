- 线程安全：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调用代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为那么就称这个类是线程安全的。
- 竟态条件：
	- 解释
		- 例如：i++；分为三步“读取-修改-写入”;
		- 延迟初始化中的竟态条件（单例模式）,"先检查后执行".
		 ```java
		 //示例
		 @NotThreeSafe  
			public class LazyInitRace {  
			    private ExpensiveObject instance=null;  
			    public ExpensiveObject getInstance(){  
			        if (instance==null){  
			            instance=new ExpensiveObject();  
			        }  
			        return instance;  
			    }  
			}```
		- 在不恰当的执行时序下会出现不准确的结果。可能会基于一种失效观察结果来作出判断或计算（先检查后执行）
		- 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条
	- 方案：
		- 让对应的方式以原子方式执行（或者说不可分割）
		- 在某个线程改变变量时，通过某种方式防止其他线程使用这个变量，从而保障其他线程只能在修改操作完成前后读取和修改状态，而不是在修改状态的过程中。
		- 复合操作：包含了一组必须以原子方式执行的操作以保证线程安全（“读取-修改-写入”和”先检查后执行“；
	- 关于锁：
		- Java中的同步代码块（synchronized block）：是一种实现同步访问共享资源的机制。在Java中，多线程访问共享资源时可能会出现线程安全问题，同步代码块提供了一种解决这个问题的方法。同步代码块通过使用一个锁对象来实现同步访问，只有获得锁的线程才能执行同步代码块中的代码，其他线程则需要等待锁被释放。锁对象可以是任何Java对象，但是建议使用专门为此目的创建的对象，以避免与其他代码产生竞争.当一个线程进入同步代码块时，它会尝试获得锁对象的锁，如果锁已经被其他线程占用，则该线程将被阻塞，直到锁被释放。当同步代码块执行完成后，锁将被自动释放，其他线程则可以获得锁并继续执行同步代码块中的代码。
		```java
		synchronized (锁对象) {    
		 // 需要同步的代码块 
		 }   
		```
		- 重入：如果某个线程试图获取一个已经有他自己持有的锁，那么这个请求就会成功。重入表明获取锁的操作的粒度是“线程”而不是“调用。  
		- 锁的实现：Java线程的锁是基于monitor实现的，当一个线程获取到锁时，它会把monitor的计数器加1，当执行完synchronized代码块时，计数器会减1。如果计数器减到了0，那么锁就被释放了，其他线程就可以获取这个锁。在Java中，如果一个线程重复获取一个已经持有的锁，那么计数器会增加1，而不会把线程阻塞在那里。只有当一个线程持有一个锁时，其他线程才会被阻塞在这个锁上  
