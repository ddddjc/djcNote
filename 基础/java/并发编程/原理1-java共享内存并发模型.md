# java共享内存并发模型基础知识

## 1.并发编程有两个关键问题

- 线程间如何通讯（线程之间以何总机制交换信息）
- 线程间如何同步（线程以何种机制来控制不同现场之间操作发生的相对顺序）

有两种并发内存模型可以解决这两个问题

- 消息传递并发模型
- 共享内存并发模型

这两种模型之间的区别如下表：

|                  | 如何通信                                                     | 如何同步                                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 消息传递并发模型 | 线程中间没有公共状态，线程间的通信必须通过发送消息来显示进行通讯 | 发送消息天然同步，因为发送消息总在接受消息之前，因此同步是隐式的。 |
| 共享内存并发模型 | 线程之间共享程序的公共状态，通过写-读内存中的共享状态进行隐式通信 | 必须显式指定某段代码需要在线程之间互斥同步，同步是显示的。   |

**java使用的是共享内存并发模型**

## 2.java内存模型的抽象结构

### 2.1运行时内存的划分

对于每个线程来说，栈都是私有的，而堆是共有的

也就算说栈中的变量（局部变量、方法定义参数、异常处理参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响，而在堆中的变量是共享的。

>  所以内存可见性针对的是**共享变量**

![](https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

### 2.2既然堆是共享的，为什么在堆中会有内存不可见的问题？

这是因为现代计算机为了高效。往往会在[高速缓冲区](https://www.cnblogs.com/binarylei/p/12588944.html)中缓存共享变量，因为cpu访问缓冲区比访问内存要快得多。

> 线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读写共享变量的副本。本地内存是java内存模型的一个抽象概念，并不是真实存在的。它涵盖了缓存、写缓存区、寄存器等。

Java线程中间的通信有Java内存模型（简称JMM）控制，从抽象的角度来说，JMM定义了线程和主内存之间的抽象关系。JMM的抽象示意图如下图所示

![a](https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/JMM%E6%8A%BD%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

由图可以看出：

1. 所有的共享变量都存在内存中。
2. 每个线程都保存了一份该线程使用到的共享变量的副本
3. 如果线程A与线程B之间要通话时，必须经过一下两个步骤：
   1. 线程A将本地内存A中更新过的共享变量刷到主内存中区。
   2. 线程B到主内存中区读取线程A之前已经更新过的共享变量。

**所以，线程A无法直接访问线程B的工作内存，线程间通信必须经过主内存。**

> 注意。根据JMM的规定，**线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。**

所以线程B并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个变量，发现这个变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B在读取本地内存B中的新值



那么怎么知道这个共享变量被其他线程修改了？

这就是JMM的功劳了，也就算JMM存在的必要性之一：

* JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。

> Java中的volatile关键字可以保证多线操作共享变量的可见性以及禁止指令重排序，synchronized关闭字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序。
>
> 为了方便理解，提出了happens-before，它更加的简单易懂，从而避免了为了理解内存可见性而去学习复杂的重排序规则以及这些具体实现方法。

2.3 JMM与java内存区域划分的区别与联系

二者既有错别又有联系：

- 区别：

  二者是不同的概念层次。JMM是抽象的，它是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。

- 联系：

  都存在私有数据区和共享数据区域。一般来说，JMM中的主内存属于数据共享区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有程序计数器，本地方法栈，虚拟机栈。



> 参考：
>
> [6 Java内存模型基础知识 - 深入浅出Java多线程 (gitbook.io)](https://redspider.gitbook.io/concurrent/di-er-pian-yuan-li-pian/6#6.2.3-jmm-yu-java-nei-cun-qu-yu-hua-fen-de-qu-bie-yu-lian-xi)