# 3 共享模型

**线程安全**：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调用代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为那么就称这个类是线程安全的。

## 3.1. 共享带来的问题

### 临界区

- 一个程序运行多个线程本身是没有问题的
- 问题出在多个线程访问**共享资源**
  - 多个线程读**共享资源**其实也没问题
  - 在多个线程对共享资源**读写**操作时发生指令交错，就会出现问题（a修改资源时先读取，后修改，写入。若在这之间数据被其他线程修改，就发生了问题）
- 一段代码内如果存在对**共享资源**的多线程读写操作，称这段代码为**临界区**

### 竟态条件

多个线程在临界区内执行，由于代码的**执行顺序不同**而导致结果无法预测，称之为发生了**竞态条件**

方案：

- 让对应的方式以原子方式执行（或者说不可分割）
- 在某个线程改变变量时，通过某种方式防止其他线程使用这个变量，从而保障其他线程只能在修改操作完成前后读取和修改状态，而不是在修改状态的过程中。
- 复合操作：包含了一组必须以原子方式执行的操作以保证线程安全（“读取-修改-写入”和”先检查后执行“；

## 3.2 synchronized解决方案

### 关于锁：

- Java中的同步代码块（synchronized block）：是一种实现同步访问共享资源的机制。在Java中，多线程访问共享资源时可能会出现线程安全问题，同步代码块提供了一种解决这个问题的方法。同步代码块通过使用一个锁对象来实现同步访问，只有获得锁的线程才能执行同步代码块中的代码，其他线程则需要等待锁被释放。锁对象可以是任何Java对象，但是建议使用专门为此目的创建的对象，以避免与其他代码产生竞争.当一个线程进入同步代码块时，它会尝试获得锁对象的锁，如果锁已经被其他线程占用，则该线程将被阻塞，直到锁被释放。当同步代码块执行完成后，锁将被自动释放，其他线程则可以获得锁并继续执行同步代码块中的代码。

```java
        synchronized (锁对象) {    
         // 需要同步的代码块 需要注意的是，代码块应保证原子性。
         }

```

- 重入：如果某个线程试图获取一个已经有他自己持有的锁，那么这个请求就会成功。重入表明获取锁的操作的粒度是“线程”而不是“调用。  
- 锁的实现：Java线程的锁是基于monitor实现的，当一个线程获取到锁时，它会把monitor的计数器加1，当执行完synchronized代码块时，计数器会减1。如果计数器减到了0，那么锁就被释放了，其他线程就可以获取这个锁。在Java中，如果一个线程重复获取一个已经持有的锁，那么计数器会增加1，而不会把线程阻塞在那里。只有当一个线程持有一个锁时，其他线程才会被阻塞在这个锁上  

### 加在方法上

需要注意的是 synchronized锁的是**对象**

```java
    public synchronized voi d test(){
        //方法体
    }
==>等价
    public void test(){
        synchronized (this){
            //方法体
        }
    }

public class lock {
    public synchronized static void test(){
        
    }
    ==>
    public static void test(){
        synchronized (lock.class){
            
        }
    }
}

```

**不加synchronized 的方法不能保证线程安全**

### 线程八锁（注意synchronized锁的规律）

## 3.3变量的线程安全问题

### 成员变量和竟态变量是否线程安全？

- 如果他们没有被从共享，则线程安全
- 如果他们被共享了，根据他们的状态是否发生改变，又分两种情况
  - 如果只有读操作，则线程安全
  - 如果有写操作，则代码是临界区，需要考虑线程安全

### 局部变量是否线程安全

- 局部变量是线程安全的
- 但局部变量引用的对象未必
  - 如果该对象没有逃离方法的作用访问，它是线程安全的
  - 如果该对象逃离方法的作用范围，需要考虑线程安全。

```java
    public static void test(){
        int i=10;
        i++;
    }
```

- 每个线程调用test（）方法时会在每个线程的2栈帧内存中被创建多份，因此不存在共享![image-20230716101407120](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202307161014211.png)

- 局部变量不共享的内存  ![image-20230716102400335](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202307161024423.png)
-  可能会导致不安全的问题：
  - 方法被继承后，重写，重写的方法里面创建了一个新的线程，另外这个新的线程使用局部变量，导致局部变量被共享，进而产生线程安全问题。
  - 解决：把方法状态修饰符改为private，让他不能被重写，或者把方法设为final。
- ![image-20230716103015916](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202307161030976.png)

### 常见线程安全类

- String
- Integer等包装类
- StringBuffer
- Random
- Vertor
- Hashtable
- java.util.concurrent 包下的类

这里说他们是线程安全是指。多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为

- 他们的每个方法都是原子的
- 但**注意**他们多个方法的组合不是原子的。

```java
	Hashtable table=new Hashtable();
	if(table.get("key")==null){
        table.put("key",value);
    }
    /*
    如果不同的线程交替调用，会出现线程不安全问题。
    */
```

### 不可变类线程安全

例如String和Integer都是不可变类，因为其内部的状态不可改变，因此他们的方法都是线程安全的。

（String修改后会返回一个新的字符串）

## 3.4Monitor

Monitor 翻译：**监视器**或**管理**

- Java线程的锁是基于monitor实现的，当一个线程获取到锁时，它会把monitor的计数器加1，当执行完synchronized代码块时，计数器会减1。如果计数器减到了0，那么锁就被释放了，其他线程就可以获取这个锁。在Java中，如果一个线程重复获取一个已经持有的锁，那么计数器会增加1，而不会把线程阻塞在那里。只有当一个线程持有一个锁时，其他线程才会被阻塞在这个锁上  

每一个对象都可以关联一个Monitor对象，如果使用使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针

Monitor结构如下![image-20230716170326418](https://cdn.jsdelivr.net/gh/mydy930657303/djcPicture@master/202307161703524.png)

- 刚开始Monitor中Owner为null
- 当Thread-2执行synchronized（Object）就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner
- 在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized（obj），就会进入EntryList BLOCKED
- Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时候是非公平的
- 图中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足WAITING状态的线程，后面讲wait-notify时会分析

> 注意
>
> - synchronized必须是进入同一个对象的Monitor才有上述效果
> - 不加synchronized的对象不会关联监视器，不遵从以上规则

### **原理之synchronized**

#### 1.轻量级锁

 
