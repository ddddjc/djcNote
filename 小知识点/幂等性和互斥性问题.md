# 幂等性

## 1.什么是幂等性

幂等是一个数学与计算机学概念，在数学中某一元运算为幂等时，其作用在任一元素两次后会和其作用在一次的结果相同

> 所谓接口幂等性就是一次和多次请求某一资源对于资源本身应该有一样的结果
>
> 及在接口重复调用的情况下，对系统产生的影响是一样的

## 2.为什么需要幂等性

会有一下情景：

- 在App中下订单式，点击确认之后，没有反应 ，就又点击了几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题
- 在接受消息的时候，消息推送重复。如果处理消息接口无法保证幂等性，那么重复消费消息产生的影响可能会非常大

> 在分布式环境中，网络环境更加复杂因前端操作抖动、网络故障、消息重复、响应速度慢等原因，对接口的重复调用概率会比集中式环境下更大，尤其是重复消息在分布式环境中很难避免

分布式环境中，有些接口是天然保证幂等性的，如查询操作。有些对数据的修改是一个常量，并且无其他记录和操作，那么也可以说是具有幂等性的。其他情况下，所有涉及对数据的修改、状态的变化就都有必要防止重复性操作的发生。通过简介实现接口的幂等性来防止重复操作带来的影响，传奇饿了一种有效的解决方案。

## 3.解决方案：

#### 1. 数据库唯一主键实现幂等性

数据库唯一主键的实现主要是利用数据库中主键约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条该唯一主键的记录。

使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式ID充当主键，这样才能保证分布式环境下ID的全局唯一性。

适用操作：

- 插入操作
- 删除操作

使用限制

- 需要生成全局唯一主键ID；

![img](https://cdn.jsdelivr.net/gh/ddddjc/djcPicture@master/202312282327286.webp)

主要流程：

1. 客户端执行创建请求，调用服务端接口
2. 服务端执行业务逻辑，生成一个分布式ID，将该ID充当插入数据的主键，然后执行数据插入操作，运行对应的SQL语句
3. 服务端将该条数据插入到数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。

#### 2. 数据库乐观锁实现幂等性

数据库乐观锁方案一般只能适用于属性**更新操作**的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。

这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新中版本标识的值。

适用操作：更新操作

使用限制：需要数据库对应业务表中添加额外字段

![img](https://cdn.jsdelivr.net/gh/ddddjc/djcPicture@master/202312282334835.webp)

#### 3.token机制实现

通过token机制实现接口的幂等性，这是一种比较通用的实现方法

![img](https://cdn.jsdelivr.net/gh/ddddjc/djcPicture@master/202312291443505.webp)

流程：

1. 客户端会先发送一个请求去获取token，服务端会生成一个全局唯一的ID作为token保存在redis中，同时把这个ID返回给客户端
2. 客户端第二次调用业务请求的时候必须携带这个token
3. 服务端会校验这个token，如果校验成功，则执行业务，并删除redis中的token
4. 如果校验失败，则说明redis中已经没有对应的token，则表示重复操作，直接返回指定的结果给客户端

注意：

1. 对redis中是否存在token以及删除的代码逻辑建议用Lua脚本实现，保证原子性
2. 全局唯一ID可以用百度的uid-generator、美团的Leaf去生成

#### 4.基于redis实现

这种实现方式是基于SETNX命令实现的

SETNX key value：将key的值设为value，当且仅当key不存在。若给定的key已经存在，则SETNX不做任何动作。

该命令在设置成功时返回1，设置失败时返回0。

![img](https://cdn.jsdelivr.net/gh/ddddjc/djcPicture@master/202312291454435.webp)

流程：

1. 客户端先请求服务器，会拿到一个能代表这次请求业务的唯一字段
2. 将该字段以SETNX的方式存入redis中，并根据业务设置相应的超时时间
3. 如果设置成功，证明这时第一次请求，则执行后续的业务逻辑
4. 如果设置失败，则代表已经执行过当前请求，直接返回

#### 终结：

除此之外还有其他的方案，比如使用状态机、悲观锁、乐观锁的方式来实现

# 互斥性

例子：

**例1：**某服务记录关键数据X，当前值为100。A请求需要将X增加200；同时，B请求需要将X减100。
在理想的情况下，A先读取到X=100，然后X增加200，最后写入X=300。B请求接着从读取X=300，减少100，最后写入X=200。
然而在真实情况下，如果不做任何处理，则可能会出现：A和B同时读取到X=100；A写入之前B读取到X；B比A先写入等等情况。

**例2：**某服务提供一组任务，A请求随机从任务组中获取一个任务；B请求随机从任务组中获取一个任务。
在理想的情况下，A从任务组中挑选一个任务，任务组删除该任务，B从剩下的的任务中再挑一个，任务组删除该任务。
同样的，在真实情况下，如果不做任何处理，可能会出现A和B挑中了同一个任务的情况。



> 互斥性的问题来讲，就是对资源共享的抢占问题。如果不同的请求对同一个或者同一组资源读取并修改时，无法保证按序执行，无法保证一个操作的原子性，那么就很有可能会出现预料外的情况。因此操作的互斥性问题，也可以理解为一个需要保证时序性、原子性的问题。**类似于mysql中的脏读、幻读、不可重复度的情况**



在传统的基于数据库的框架中，对于数据的抢占问题往往是通过数据库事务（ACID）来保证的。在分布式环境中，出于对性能以及一致性敏感的要求，使得分布式锁成为了一种比较常见而高效的解决方案。

不止如此，传统的多线程、多进程情况下也会有操作互斥性问题，不过已经有了较好的解决方案。可以根据这两种情况的解决方案来对分布锁提供一些实现思路



## 多线程环境解决方案及原理

### 解决方案：

《Thinking in Java》 书中写到：

> 基本上所有的并发模式在解决线程冲突时，都是采用序列化访问共享资源的方案。

在多线程环境中，线程之间因为公用一些存储空间，冲突问题时有发生。解决冲突问题追普遍的方式就是用互斥锁吧该资源活对该资源的操作保护起来。

Java JDK中提供了两种互斥锁Lock和synchronized。不同的线程之间对同一资源进行抢占，该资源通常表现为某个类的普通成员变量。因此，利用ReentrantLock或者synchronized将共享变量及其操作锁住，即可基本解决资源抢占问题

### 原理

#### ReentrantLock

ReentrantLock主要利用CAS+CLH队列来实现。它支持公平锁和非公平锁，两者的实现类似。

- CAS：Compare and Swap,比较并交换。CAS有三个操作数：内存值V，预期值A，要修改的新值B。当且仅当预期值A与内存值V相等时，将内存值V修改为B，否则什么都不做。该操作是一个原子操作，被广泛的应用在Java的底层实现中。在Java中，CAS主要是有sun.misc.Unsafe这个类通过JNI调用CPU底层指令来实现。
- CLH队列：带头节点的双向非循环链表

![img](https://cdn.jsdelivr.net/gh/ddddjc/djcPicture@master/202312301145907.webp)



ReentrantLock地基本实现可以概括为：先通过CAS尝试获取锁，如果已经有线程占据了锁，那就加入CLH队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：

- 非公平锁：如果同时还有另一个线程来尝试获取锁，那么有可能会让这个线程抢先获取
- 公平锁：如果同时还有另一个线程来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁

分析代码：

~~~java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
~~~

在尝试获取锁时，会先调用上面的方法。如果状态为0，则表明此时无人占由锁。此时尝试进行set，一旦成功，则则成功占有锁。如果状态不为0，再判断是否是当前线程获取到锁。如果是的话，将状态+1，因为此时就是当前线程，所以不用CAS。这也就是可重入锁的实现原理。

~~~java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}
~~~

该方法是在尝试获取锁失败加入到CHL队尾之后，如果发现前序节点是head，则CAS再尝试获取一次。否则会根据前序节点的状态判断是否需要阻塞。如果需要阻塞，则调用LockSupport的park方法阻塞该线程。

#### synchronized

在Java语言中存在两种内建的synchronized语法：synchronized语句、synchronized方法。

- synchronized语句：当源码被编译成字节码时，会在同步块的入口位置和退出位置分别插入monitorenter和monitorexit字节码指令；
- synchronized方法：在Class文件的方案表中将该方法的access_flags字段中的synchronized标志位1.这个specification中没有明确说明。

##### monitorenter

每个对象都有一个锁，也就是监视器（monitor）。当monitor被占有时就表示它被锁定。线程执行monitorenter指令时尝试获取对象所对应的monitor的所有权，过程如下：

- 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者
- 如果线程已经拥有了该monitor，只是重新进入，则重新进入，则进入monitor的进入数加1
- 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

##### monitorexit

执行monitorexit的线程必须是相应的monitor的所有者。

指令执行时，monitor的进入数减1，如果键1后进入数为0，那么线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。

在JDK1.6及其之前的版本中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。然而在现实中的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境）。如果每次都调用Mutex Lock将严重的影响程序的性能。因此在JDK 1.6之后的版本中对锁的实现做了大量的优化，这些优化在很大程度上减少或避免了Mutex Lock的使用。



## 多进程环境解决方案

在多道程序系统中存在许多进程，他们共享各种资源，然而有很多资源一次只能供一个进程使用，这便是临界资源。多进程的临界资源大致上可以分为两类，一类是物理上的真实资源，如打印机；一类是硬盘或内存中的共享数据，如共享内存等。而进程内互斥访问临界资源的代码被称为临界区。

针对临界区资源的互斥访问JVM层面的锁就已经失去效力了。在多进程情况下，只要还是利用操作系统层面的进程键通信原理来解决临界资源的抢占问题。比较常见的一种方法便是使用信号量。

信号量在POSIX标准下有两种，分别为有名信号和无名信号。无名信号通常保存在共享内存中，而有名信号量是与一个特定的文件名相关联。信号是一个整数变量，有计数信号量和二值信号量两种。对信号量的操作，主要是P操作和V操作。

- P操作：先检查信号量的大小，若值大于零，则将信号量减1，同时进程获得共享资源的访问权限，继续执行；若小于或者等于零，则该进程被阻塞后，进入等待队列。
- V操作：该操作将信号量的值加1，如果有进程阻塞这等待该信号量，那么其中一个进程将被唤醒。

举个例子，设信号量为1，当一个进程A在进入临界区之前，先进行P操作。发现值大于零，那么就将信号量减为0，进入临界区执行。此时，若另一个进程B也要进去临界区，进行P操作，发现信号量等于0，则会被阻塞。当进程A退出临界区时，会进行V操作，将信号量的值加1，并唤醒阻塞的进程B。此时B就可以进入临界区了。

这种方式和多线程环境下的加锁非常类似。因此用信号量处理临界资源抢占，也可以简单地理解为对临界区进行加锁。

**对共享资源的操作前后（进出临界区）加解锁，保证不同线程或进程可以互斥有序地操作资源**

加解锁方式，有显示的加锁，如ReentrantLock或信号量；也有隐式的加解锁，如synchronized。那么在分布式环境中，为保证不同的JVM不同主机间不会出现系统资源抢占，那么同样只要对临界区加解锁计科

然而在多线程和多进程中，锁已经有表完善的实现，直接使用即可。但是在分布式环境下，就需要自己来实现分布式锁

## 分布式环境下的解决方案——分布式锁

分布式锁的基本条件

多线程和多进程环境下的锁，可以发现锁的实现有很多共同之处，他们都需要满足一些最基本的条件：

1. 需要有存储锁的空间，并且锁的空间是可以访问到的
2. 锁需要被唯一标识
3. 锁要有至少两种状态

### 存储空间

锁是一个抽象的概念，锁的实现，需要依赖于一个可以存储锁的空间。在多线程中是内存，在多进程中是内存或者磁盘。更重要的是，这个空间是可以被访问到的。多线程中，不同的线程都可以访问到堆中的成员变量；在多进程中，不同的进程可以访问到共享内存中的数据或者存储在磁盘中的文件。但是在分布式环境中，不同的主机很难访问对方的内存或磁盘。这就需要一个都能访问到的**外部空间**来作为存储空间。

最普遍的外部存储空间就是数据库了，事实上也确实有基于数据库做分布式锁（行锁、version乐观锁），如quartz集群架构就有所使用。除此之外，还有各式缓存如：Redis、Tair、Memcached、Mongodb，当然还有专门的分布式协调服务Zookeeper，甚至是另一台主机。主要以存储数据、锁在其中可以被多设计访问到，那么就可以作为分布式锁的存储空间

### 唯一标识

不同的共享资源，必然需要不同的锁进行保护，因此相应的锁必须要有唯一的标识。在多线程环境中，锁可以是一个对象，那么对这个对象的引用便是这个唯一标识。多进程环境中，信号量在共享内存中也是由引来作为唯一的标识。但如果不在内存中，失去了对锁的引用，如何唯一标识它？可以用硬盘中的文件名作为唯一标识。因此，在分布式环境中，只要给这个锁设定一个名称，并保证这个名称是全局唯一的，那么就可以作为唯一标识。

### 至少两种状态

为了给临界区加锁和解锁，需要存储两种不同的状态。如ReentrantLock中的status，0表示没有线程竞争，大于0表示有线程竞争；信号量大于0表示可以进入临界区，小于等于0则表示需要被阻塞。因此只要在分布式环境中，锁的状态由两种或以上：如有锁、没锁；存在、不存在等等，均可以实现。

有了这三个条件，基本就可以实现一个简单的分布式锁了。下面以数据库为例，实现一个简单的分布式锁：

数据库表，字段为锁的ID，锁的状态（0表示没被锁，1表示被锁）。

~~~java
lock = mysql.get(id);
while(lock.status == 1) {
    sleep(100);
}
mysql.update(lock.status = 1);
doSomething();
mysql.update(lock.status = 0);
~~~

### 这样实现的问题：

分布式锁的基础条件

1. 锁状态的原子性无法保证

   从读取锁的状态，到判断该状态是否为被锁，需要经历两步操作。如果不能保证这两步的原子性，就可能导致不止一个请求获取到了锁，这显然是不行的。因此，我们需要保证锁状态判断的原子性。

2. 网络断开或主机宕机，锁状态无法清除

   假设在主机已经被获取到锁的情况下，突然出现了网络断开或主机宕机，如果不做任何处理，该说将仍然处于被说定的状态，后续的所有请求都无法获取到锁。因此需要再持有锁的主机宕机或者网络断开时，及时的释放掉这把锁。

3. 无法保证释放的是自己上锁的那把锁

   如果上一个问题解决了，那么如果主机A占有了锁后遇到网络抖动或者其他情况断开连接，分布式锁被释放掉，然后主机B占有了锁，后A恢复连接，释放锁，会把B占有的锁释放掉，而B运行结束时也可能会释放掉其他主机上的锁，这锁就上去了意义。因此，需要在解锁时，确定自己解的锁是自己上锁的那把、

### 进阶条件

如果解决了上面的三个问题，就可以是一个较为完整的分布式锁了，但在实际应用中，还会有更高级的需求

1. 可重入：线程中的可重入，指的是外层函数获得锁之后，内层也可以获得锁，ReentrantLock和synchronized都是可重入锁；衍生到分布式环境中，一般仍然指的是线程的可重入，在绝大多数分布式环境中，都要求分布式锁是可重入的。
2. 惊群效应：在分布式锁中，惊群效应指的是，在有多个请求等待获取锁的时候，一旦占有锁的线程释放之后，所有等待方都同时被唤醒，尝试抢占锁。但是这样的情况会还下次较大的开销，那么在实现分布式锁的时候，应尽量避免惊群效应的产生
3. 公平锁和非公平锁：不同的需求，可能需要不同的分布式锁。非公平锁普遍比公平锁开销小。但是业务需求如果必须要锁的竞争者按顺序获取锁，那么就需要实现公平锁
4. 阻塞锁和自旋锁：针对不同的使用场景，阻塞锁和自旋锁的效率不同。阻塞锁会有上下文的切换，如果并发量比较高且临界区的操作耗时较短，那么造成的性能开销就比较大了。到那时如果临界区操作耗时比较长，一直保存自旋，也会对CPU造成更大的负荷。

